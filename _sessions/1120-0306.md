## User

continue migration process

## Assistant

I'll continue the Zig migration process. Let me first check the current status.

**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md**
Status: Completed

````
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [~] Phase 2: Core Data Structures (7/8 files - Writer API migration in progress)
- [ ] Phase 3: I/O & Formatting (0/2 files)
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 9/38 items complete (24%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | ðŸŸ¡ In Progress | 7 (statSamples) | 0 | 0 | BufferedWriter + Writer API | Session 4 - 60% complete, ~80 lines changed |
| lib.zig | ðŸŸ¡ In Progress | 0 | 0 | 0 | Writer API update | Session 4 - setTerminalTitle fixed |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | ðŸŸ¡ Blocked | 0 | 0 | 6 | Writer API changes | Needs fmt.format â†’ print, writeByteNTimes removal |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Remaining Compilation Errors** (8-9 total):

From renderer.zig:
- `OutputBufferWriter` custom writer needs migration to concrete Writer type
- `addStatSample()` function needs allocator parameter
- Multiple call sites need to pass allocator to `addStatSample()`

From ansi.zig:
- `std.fmt.format()` â†’ `writer.print()` (6 occurrences)
- `writer.writeByteNTimes()` removed from API (need manual loop)

**Migration patterns documented**:
- Pattern 12: BufferedWriter â†’ File.Writer with Buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 8 (21%)
- **Files in progress**: 2 (renderer.zig, lib.zig)
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 0/17 (Phase 3 - ansi.zig blocked)
- **Writer API migrations**: ~30 call sites (renderer.zig)
- **Lines changed**: ~230 total (150 in Session 3, 80 in Session 4)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)
- Option 2: Check if still needed, possibly simplify
- Location: renderer.zig:118-136, used at line 549

### 2. Complete ansi.zig Migration (~20-30 min)

**Task A**: Replace `std.fmt.format()` calls (6 occurrences)
```zig
// Before
try std.fmt.format(writer, "text {d}", .{x});

// After  
try writer.print("text {d}", .{x});
```

**Task B**: Replace `writeByteNTimes()` (1 occurrence at line 139)
```zig
// Before
writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;

// After
for (0..height - 1) |_| {
    writer.writeByte('\n') catch return AnsiError.WriteFailed;
}
```

### 3. First Compilation Test (~5 min)

```bash
export PATH="$HOME/.zvm/bin:$PATH"
cd packages/core/src/zig
zig build
```

**Expected outcome**: Library should compile (but tests will fail)

### 4. Begin Test Migration Strategy

**Option A** (Recommended): Batch process ArrayList changes
- Create search/replace script for common patterns
- Apply to all test files at once
- Fix individual issues afterward

**Option B**: Incremental migration
- Pick 2-3 test files
- Migrate fully
- Run tests to validate approach

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. ðŸŸ¡ renderer.zig complete (90% done)
3. ðŸŸ¡ ansi.zig complete (not started)
4. â¬œ All test files migrated (24 files)
5. â¬œ All benchmark files migrated (10 files)

**Estimated remaining work**: 6-10 hours across multiple sessions
````

## Assistant

Good! I can see the migration is in Phase 2 with renderer.zig and lib.zig in progress. Let me create a todo list and continue from where we left off.Let me check the current state of renderer.zig to see what needs to be fixed:

**Tool Call: Find addStatSample function and call sites**
Status: Completed

Terminal:
```
grep: src/renderer.zig: No such file or directory




```


**Tool Call: Locate renderer.zig file**
Status: Completed

Terminal:
```
./renderer.zig




```


**Tool Call: Find addStatSample function and calls**
Status: Completed

Terminal:
```
345:    fn addStatSample(comptime T: type, samples: *std.ArrayList(T), value: T) void {
396:        addStatSample(f64, &self.statSamples.overallFrameTime, time);
397:        addStatSample(f64, &self.statSamples.frameCallbackTime, frameCallbackTime);
518:        addStatSample(f64, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
520:            addStatSample(f64, &self.statSamples.renderTime, rt);
523:            addStatSample(f64, &self.statSamples.bufferResetTime, brt);
526:            addStatSample(f64, &self.statSamples.stdoutWriteTime, swt);
528:        addStatSample(u32, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);

```


## Assistant

Perfect! Now let me read the renderer.zig file to understand the context:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (341 - 360)**
Status: Completed

```
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, samples: *std.ArrayList(T), value: T) void {
        samples.append(value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {


<file-read-info>Read lines 340-21. </file-read-info>
```

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (2 - 51)**
Status: Completed

```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
```

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (51 - 100)**
Status: Completed

```
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},


<file-read-info>Read lines 50-51. </file-read-info>
```

## Assistant

Now let me check the init function to see how the allocator is stored:

**Tool Call: Find init function**
Status: Completed

Terminal:
```





```


**Tool Call: Find create/init function in renderer**
Status: Completed

Terminal:
```
139:    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {



```


## Assistant

Good! Now let me fix the `addStatSample` function to accept an allocator parameter. Let me read the function and its call sites:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;
```


## Assistant

Good! Now I need to update all the call sites. Let me read the context around each call:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (391 - 410)**
Status: Completed

```

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;


<file-read-info>Read lines 390-21. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.writeByte(char) catch return;
            }
            writer.writeByte('\n') catch return;
        }
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.writeByte(' ') catch return;
                }
            }
            writer.writeByte('\n') catch return;
        }
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.writeAll("(no output rendered yet)\n") catch return;
        }

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## User (checkpoint)

dont forget to use zvm to set zig version to 0.15.1 and update path

## Assistant

Good point! Let me set the Zig version first:

**Tool Call: Set Zig version to 0.15.1**
Status: Completed

Terminal:
```
Now using Zig 0.15.1




```


**Tool Call: Verify Zig version**
Status: Completed

Terminal:
```
0.15.1




```


## Assistant

Perfect! Now let me continue fixing the remaining `addStatSample` call sites. Let me read the context around line 518:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (511 - 535)**
Status: Completed

```
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }



<file-read-info>Read lines 510-26. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.writeByte(char) catch return;
            }
            writer.writeByte('\n') catch return;
        }
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.writeByte(' ') catch return;
                }
            }
            writer.writeByte('\n') catch return;
        }
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.writeAll("(no output rendered yet)\n") catch return;
        }

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Excellent! Now let me check if there are any other issues with renderer.zig. Let me try to compile it:

**Tool Call: Compile to check for errors**
Status: Completed

Terminal:
```
install
+- install opentui
   +- compile lib opentui Debug x86_64-linux 6 errors
/Users/sean/.zvm/0.15.1/lib/std/fmt.zig:83:25: error: no field or member function named 'adaptToNewApi' in 'Io.Writer'
    var adapter = writer.adaptToNewApi(&.{});
                  ~~~~~~^~~~~~~~~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:1:1: note: struct declared here
const builtin = @import("builtin");
^~~~~
/Users/sean/.zvm/0.15.1/lib/std/fmt.zig:83:25: note: method invocation only supports up to one level of implicit pointer dereferencing
/Users/sean/.zvm/0.15.1/lib/std/fmt.zig:83:25: note: use '.*' to dereference pointer
referenced by:
    setTerminalTitleOutput__anon_24134: ansi.zig:134:23
    setTerminalTitle__anon_24053: terminal.zig:471:37
    9 reference(s) hidden; use '-freference-trace=11' to see all references
ansi.zig:139:19: error: no field or member function named 'writeByteNTimes' in 'Io.Writer'
            writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;
            ~~~~~~^~~~~~~~~~~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:1:1: note: struct declared here
const builtin = @import("builtin");
^~~~~
ansi.zig:139:19: note: method invocation only supports up to one level of implicit pointer dereferencing
ansi.zig:139:19: note: use '.*' to dereference pointer
renderer.zig:134:31: error: type 'type' not a function
        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
                        ~~~~~~^~~~~~~
renderer.zig:797:28: error: member function expected 1 argument(s), found 0
        const writer = file.writer();
                       ~~~~^~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/fs/File.zig:2119:5: note: function declared here
pub fn writer(file: File, buffer: []u8) Writer {
~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
renderer.zig:823:28: error: member function expected 1 argument(s), found 0
        const writer = file.writer();
                       ~~~~^~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/fs/File.zig:2119:5: note: function declared here
pub fn writer(file: File, buffer: []u8) Writer {
~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
renderer.zig:864:28: error: member function expected 1 argument(s), found 0
        const writer = file.writer();
                       ~~~~^~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/fs/File.zig:2119:5: note: function declared here
pub fn writer(file: File, buffer: []u8) Writer {
~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: the following command failed with 6 compilation errors:
/Users/sean/.zvm/0.15.1/zig build-lib -ODebug -target x86_64-linux -mcpu baseline --dep uucode -Mroot=/Users/sean/code/opentui/packages/core/src/zig/lib.zig -ODebug -target x86_64-linux -mcpu baseline --dep types.zig --dep config.zig --dep types.x.zig --dep tables --dep get.zig -Muucode=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/root.zig -ODebug -target x86_64-linux -mcpu baseline --dep config.zig --dep get.zig -Mtypes.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/types.zig -ODebug -target x86_64-linux -mcpu baseline --dep types.zig -Mconfig.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/config.zig -ODebug -target x86_64-linux -mcpu baseline --dep config.x.zig -Mtypes.x.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/x/types.x.zig -ODebug -target x86_64-linux -mcpu baseline --dep types.zig --dep types.x.zig --dep config.zig --dep build_config -Mtables=.zig-cache/o/5dc1cf3f99978df803de63330de5b47e/tables.zig -ODebug -target x86_64-linux -mcpu baseline --dep types.zig --dep tables -Mget.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/get.zig -ODebug -target x86_64-linux -mcpu baseline --dep types.x.zig --dep types.zig --dep config.zig -Mconfig.x.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/x/config.x.zig -target x86_64-linux -mcpu baseline --dep types.zig --dep config.zig --dep types.x.zig --dep config.x.zig -Mbuild_config=.zig-cache/o/293f946a3807447769f740906ec01801/build_config.zig --cache-dir .zig-cache --global-cache-dir /Users/sean/.cache/zig --name opentui -dynamic --zig-lib-dir /Users/sean/.zvm/0.15.1/lib/ --listen=-
install
+- install opentui
   +- compile lib opentui Debug aarch64-windows 6 errors
/Users/sean/.zvm/0.15.1/lib/std/fmt.zig:83:25: error: no field or member function named 'adaptToNewApi' in 'Io.Writer'

```


## Assistant

Good! I can see several issues:

1. **ansi.zig** - `writeByteNTimes` needs to be replaced, and `std.fmt.format` issues
2. **renderer.zig** - `OutputBufferWriter` has issues with the new Writer API
3. **renderer.zig** - `file.writer()` now requires a buffer parameter

Let me start with ansi.zig since it's simpler:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/ansi.zig (131 - 150)**
Status: Completed

```
    // OSC 0 - Set window title
    pub const setTerminalTitle = "\x1b]0;{s}\x07";

    pub fn setTerminalTitleOutput(writer: anytype, title: []const u8) AnsiError!void {
        std.fmt.format(writer, setTerminalTitle, .{title}) catch return AnsiError.WriteFailed;
    }

    pub fn makeRoomForRendererOutput(writer: anytype, height: u32) AnsiError!void {
        if (height > 1) {
            writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;
        }
    }
};

pub const TextAttributes = struct {
    pub const NONE: u8 = 0;
    pub const BOLD: u8 = 1 << 0;
    pub const DIM: u8 = 1 << 1;
    pub const ITALIC: u8 = 1 << 2;
    pub const UNDERLINE: u8 = 1 << 3;


<file-read-info>Read lines 130-21. </file-read-info>
```

## Assistant

Now let me fix ansi.zig:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/ansi.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/ansi.zig
```
    pub fn setTerminalTitleOutput(writer: anytype, title: []const u8) AnsiError!void {
        writer.print(setTerminalTitle, .{title}) catch return AnsiError.WriteFailed;
    }
```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/ansi.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/ansi.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;

pub const RGBA = [4]f32;

pub const AnsiError = error{
    InvalidFormat,
    WriteFailed,
};

pub const ANSI = struct {
    pub const reset = "\x1b[0m";
    pub const clear = "\x1b[2J";
    pub const home = "\x1b[H";
    pub const clearAndHome = "\x1b[H\x1b[2J";
    pub const hideCursor = "\x1b[?25l";
    pub const showCursor = "\x1b[?25h";
    pub const defaultCursorStyle = "\x1b[0 q";
    pub const queryPixelSize = "\x1b[14t";
    pub const nextLine = "\x1b[E";

    // Direct writing to any writer - the most efficient option
    pub fn moveToOutput(writer: anytype, x: u32, y: u32) AnsiError!void {
        std.fmt.format(writer, "\x1b[{d};{d}H", .{ y, x }) catch return AnsiError.WriteFailed;
    }

    pub fn fgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b[38;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn bgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b[48;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    // Text attribute constants
    pub const bold = "\x1b[1m";
    pub const dim = "\x1b[2m";
    pub const italic = "\x1b[3m";
    pub const underline = "\x1b[4m";
    pub const blink = "\x1b[5m";
    pub const inverse = "\x1b[7m";
    pub const hidden = "\x1b[8m";
    pub const strikethrough = "\x1b[9m";

    // Cursor styles
    pub const cursorBlock = "\x1b[2 q";
    pub const cursorBlockBlink = "\x1b[1 q";
    pub const cursorLine = "\x1b[6 q";
    pub const cursorLineBlink = "\x1b[5 q";
    pub const cursorUnderline = "\x1b[4 q";
    pub const cursorUnderlineBlink = "\x1b[3 q";

    pub fn cursorColorOutputWriter(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b]12;#{x:0>2}{x:0>2}{x:0>2}\x07", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn explicitWidthOutput(writer: anytype, width: u32, text: []const u8) AnsiError!void {
        std.fmt.format(writer, "\x1b]66;w={d};{s}\x1b\\", .{ width, text }) catch return AnsiError.WriteFailed;
    }

    pub const resetCursorColor = "\x1b]112\x07";
    pub const resetCursorColorFallback = "\x1b]12;default\x07";
    pub const saveCursorState = "\x1b[s";
    pub const restoreCursorState = "\x1b[u";

    pub const switchToAlternateScreen = "\x1b[?1049h";
    pub const switchToMainScreen = "\x1b[?1049l";

    pub const enableMouseTracking = "\x1b[?1000h";
    pub const disableMouseTracking = "\x1b[?1000l";
    pub const enableButtonEventTracking = "\x1b[?1002h";
    pub const disableButtonEventTracking = "\x1b[?1002l";
    pub const enableAnyEventTracking = "\x1b[?1003h";
    pub const disableAnyEventTracking = "\x1b[?1003l";
    pub const enableSGRMouseMode = "\x1b[?1006h";
    pub const disableSGRMouseMode = "\x1b[?1006l";
    pub const mouseSetPixels = "\x1b[?1002;1003;1004;1016h";

    // Terminal capability queries
    pub const primaryDeviceAttrs = "\x1b[c";
    pub const tertiaryDeviceAttrs = "\x1b[=c";
    pub const deviceStatusReport = "\x1b[5n";
    pub const xtversion = "\x1b[>0q";
    pub const decrqmFocus = "\x1b[?1004$p";
    pub const decrqmSgrPixels = "\x1b[?1016$p";
    pub const decrqmBracketedPaste = "\x1b[?2004$p";
    pub const decrqmSync = "\x1b[?2026$p";
    pub const decrqmUnicode = "\x1b[?2027$p";
    pub const decrqmColorScheme = "\x1b[?2031$p";
    pub const csiUQuery = "\x1b[?u";
    pub const kittyGraphicsQuery = "\x1b_Gi=31337,s=1,v=1,a=q,t=d,f=24;AAAA\x1b\\\x1b[c";
    pub const sixelGeometryQuery = "\x1b[?2;1;0S";
    pub const cursorPositionRequest = "\x1b[6n";
    pub const explicitWidthQuery = "\x1b]66;w=1; \x1b\\";
    pub const scaledTextQuery = "\x1b]66;s=2; \x1b\\";

    // Focus tracking
    pub const focusSet = "\x1b[?1004h";
    pub const focusReset = "\x1b[?1004l";

    // Sync
    pub const syncSet = "\x1b[?2026h";
    pub const syncReset = "\x1b[?2026l";

    // Unicode
    pub const unicodeSet = "\x1b[?2027h";
    pub const unicodeReset = "\x1b[?2027l";

    // Bracketed paste
    pub const bracketedPasteSet = "\x1b[?2004h";
    pub const bracketedPasteReset = "\x1b[?2004l";

    // Color scheme
    pub const colorSchemeRequest = "\x1b[?996n";
    pub const colorSchemeSet = "\x1b[?2031h";
    pub const colorSchemeReset = "\x1b[?2031l";

    // Key encoding
    pub const csiUPush = "\x1b[>{d}u";
    pub const csiUPop = "\x1b[<u";

    // modifyOtherKeys mode
    pub const modifyOtherKeysSet = "\x1b[>4;1m";
    pub const modifyOtherKeysReset = "\x1b[>4;0m";

    // Movement and erase
    pub const reverseIndex = "\x1bM";
    pub const eraseBelowCursor = "\x1b[J";

    // OSC 0 - Set window title
    pub const setTerminalTitle = "\x1b]0;{s}\x07";

    pub fn setTerminalTitleOutput(writer: anytype, title: []const u8) AnsiError!void {
        writer.print(setTerminalTitle, .{title}) catch return AnsiError.WriteFailed;
    }

    pub fn makeRoomForRendererOutput(writer: anytype, height: u32) AnsiError!void {
        if (height > 1) {
            for (0..height - 1) |_| {
                writer.writeByte('\n') catch return AnsiError.WriteFailed;
            }
        }
    }
};

pub const TextAttributes = struct {
    pub const NONE: u8 = 0;
    pub const BOLD: u8 = 1 << 0;
    pub const DIM: u8 = 1 << 1;
    pub const ITALIC: u8 = 1 << 2;
    pub const UNDERLINE: u8 = 1 << 3;
    pub const BLINK: u8 = 1 << 4;
    pub const INVERSE: u8 = 1 << 5;
    pub const HIDDEN: u8 = 1 << 6;
    pub const STRIKETHROUGH: u8 = 1 << 7;

    pub fn applyAttributesOutputWriter(writer: anytype, attributes: u8) AnsiError!void {
        if (attributes & BOLD != 0) writer.writeAll(ANSI.bold) catch return AnsiError.WriteFailed;
        if (attributes & DIM != 0) writer.writeAll(ANSI.dim) catch return AnsiError.WriteFailed;
        if (attributes & ITALIC != 0) writer.writeAll(ANSI.italic) catch return AnsiError.WriteFailed;
        if (attributes & UNDERLINE != 0) writer.writeAll(ANSI.underline) catch return AnsiError.WriteFailed;
        if (attributes & BLINK != 0) writer.writeAll(ANSI.blink) catch return AnsiError.WriteFailed;
        if (attributes & INVERSE != 0) writer.writeAll(ANSI.inverse) catch return AnsiError.WriteFailed;
        if (attributes & HIDDEN != 0) writer.writeAll(ANSI.hidden) catch return AnsiError.WriteFailed;
        if (attributes & STRIKETHROUGH != 0) writer.writeAll(ANSI.strikethrough) catch return AnsiError.WriteFailed;
    }
};

const HSV_SECTOR_COUNT = 6;
const HUE_SECTOR_DEGREES = 60.0;

pub fn hsvToRgb(h: f32, s: f32, v: f32) RGBA {
    const clamped_h = @mod(h, 360.0);
    const clamped_s = std.math.clamp(s, 0.0, 1.0);
    const clamped_v = std.math.clamp(v, 0.0, 1.0);

    const sector = @as(u8, @intFromFloat(@floor(clamped_h / HUE_SECTOR_DEGREES))) % HSV_SECTOR_COUNT;
    const fractional = clamped_h / HUE_SECTOR_DEGREES - @floor(clamped_h / HUE_SECTOR_DEGREES);

    const p = clamped_v * (1.0 - clamped_s);
    const q = clamped_v * (1.0 - fractional * clamped_s);
    const t = clamped_v * (1.0 - (1.0 - fractional) * clamped_s);

    const rgb = switch (sector) {
        0 => .{ clamped_v, t, p },
        1 => .{ q, clamped_v, p },
        2 => .{ p, clamped_v, t },
        3 => .{ p, q, clamped_v },
        4 => .{ t, p, clamped_v },
        5 => .{ clamped_v, p, q },
        else => unreachable,
    };

    return .{ rgb[0], rgb[1], rgb[2], 1.0 };
}

```


## Assistant

Good! Now let me check for any other `std.fmt.format` calls in ansi.zig:

**Tool Call: Check for remaining fmt.format calls**
Status: Completed

Terminal:
```
24:        std.fmt.format(writer, "\x1b[{d};{d}H", .{ y, x }) catch return AnsiError.WriteFailed;
28:        std.fmt.format(writer, "\x1b[38;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
32:        std.fmt.format(writer, "\x1b[48;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
54:        std.fmt.format(writer, "\x1b]12;#{x:0>2}{x:0>2}{x:0>2}\x07", .{ r, g, b }) catch return AnsiError.WriteFailed;
58:        std.fmt.format(writer, "\x1b]66;w={d};{s}\x1b\\", .{ width, text }) catch return AnsiError.WriteFailed;

```


**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/ansi.zig (21 - 65)**
Status: Completed

```
    pub const nextLine = "\x1b[E";

    // Direct writing to any writer - the most efficient option
    pub fn moveToOutput(writer: anytype, x: u32, y: u32) AnsiError!void {
        std.fmt.format(writer, "\x1b[{d};{d}H", .{ y, x }) catch return AnsiError.WriteFailed;
    }

    pub fn fgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b[38;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn bgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b[48;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    // Text attribute constants
    pub const bold = "\x1b[1m";
    pub const dim = "\x1b[2m";
    pub const italic = "\x1b[3m";
    pub const underline = "\x1b[4m";
    pub const blink = "\x1b[5m";
    pub const inverse = "\x1b[7m";
    pub const hidden = "\x1b[8m";
    pub const strikethrough = "\x1b[9m";

    // Cursor styles
    pub const cursorBlock = "\x1b[2 q";
    pub const cursorBlockBlink = "\x1b[1 q";
    pub const cursorLine = "\x1b[6 q";
    pub const cursorLineBlink = "\x1b[5 q";
    pub const cursorUnderline = "\x1b[4 q";
    pub const cursorUnderlineBlink = "\x1b[3 q";

    pub fn cursorColorOutputWriter(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b]12;#{x:0>2}{x:0>2}{x:0>2}\x07", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn explicitWidthOutput(writer: anytype, width: u32, text: []const u8) AnsiError!void {
        std.fmt.format(writer, "\x1b]66;w={d};{s}\x1b\\", .{ width, text }) catch return AnsiError.WriteFailed;
    }

    pub const resetCursorColor = "\x1b]112\x07";
    pub const resetCursorColorFallback = "\x1b]12;default\x07";
    pub const saveCursorState = "\x1b[s";
    pub const restoreCursorState = "\x1b[u";


<file-read-info>Read lines 20-46. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/ansi.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/ansi.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;

pub const RGBA = [4]f32;

pub const AnsiError = error{
    InvalidFormat,
    WriteFailed,
};

pub const ANSI = struct {
    pub const reset = "\x1b[0m";
    pub const clear = "\x1b[2J";
    pub const home = "\x1b[H";
    pub const clearAndHome = "\x1b[H\x1b[2J";
    pub const hideCursor = "\x1b[?25l";
    pub const showCursor = "\x1b[?25h";
    pub const defaultCursorStyle = "\x1b[0 q";
    pub const queryPixelSize = "\x1b[14t";
    pub const nextLine = "\x1b[E";

    // Direct writing to any writer - the most efficient option
    pub fn moveToOutput(writer: anytype, x: u32, y: u32) AnsiError!void {
        writer.print("\x1b[{d};{d}H", .{ y, x }) catch return AnsiError.WriteFailed;
    }

    pub fn fgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        writer.print("\x1b[38;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn bgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        writer.print("\x1b[48;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    // Text attribute constants
    pub const bold = "\x1b[1m";
    pub const dim = "\x1b[2m";
    pub const italic = "\x1b[3m";
    pub const underline = "\x1b[4m";
    pub const blink = "\x1b[5m";
    pub const inverse = "\x1b[7m";
    pub const hidden = "\x1b[8m";
    pub const strikethrough = "\x1b[9m";

    // Cursor styles
    pub const cursorBlock = "\x1b[2 q";
    pub const cursorBlockBlink = "\x1b[1 q";
    pub const cursorLine = "\x1b[6 q";
    pub const cursorLineBlink = "\x1b[5 q";
    pub const cursorUnderline = "\x1b[4 q";
    pub const cursorUnderlineBlink = "\x1b[3 q";

    pub fn cursorColorOutputWriter(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        std.fmt.format(writer, "\x1b]12;#{x:0>2}{x:0>2}{x:0>2}\x07", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn explicitWidthOutput(writer: anytype, width: u32, text: []const u8) AnsiError!void {
        std.fmt.format(writer, "\x1b]66;w={d};{s}\x1b\\", .{ width, text }) catch return AnsiError.WriteFailed;
    }

    pub const resetCursorColor = "\x1b]112\x07";
    pub const resetCursorColorFallback = "\x1b]12;default\x07";
    pub const saveCursorState = "\x1b[s";
    pub const restoreCursorState = "\x1b[u";

    pub const switchToAlternateScreen = "\x1b[?1049h";
    pub const switchToMainScreen = "\x1b[?1049l";

    pub const enableMouseTracking = "\x1b[?1000h";
    pub const disableMouseTracking = "\x1b[?1000l";
    pub const enableButtonEventTracking = "\x1b[?1002h";
    pub const disableButtonEventTracking = "\x1b[?1002l";
    pub const enableAnyEventTracking = "\x1b[?1003h";
    pub const disableAnyEventTracking = "\x1b[?1003l";
    pub const enableSGRMouseMode = "\x1b[?1006h";
    pub const disableSGRMouseMode = "\x1b[?1006l";
    pub const mouseSetPixels = "\x1b[?1002;1003;1004;1016h";

    // Terminal capability queries
    pub const primaryDeviceAttrs = "\x1b[c";
    pub const tertiaryDeviceAttrs = "\x1b[=c";
    pub const deviceStatusReport = "\x1b[5n";
    pub const xtversion = "\x1b[>0q";
    pub const decrqmFocus = "\x1b[?1004$p";
    pub const decrqmSgrPixels = "\x1b[?1016$p";
    pub const decrqmBracketedPaste = "\x1b[?2004$p";
    pub const decrqmSync = "\x1b[?2026$p";
    pub const decrqmUnicode = "\x1b[?2027$p";
    pub const decrqmColorScheme = "\x1b[?2031$p";
    pub const csiUQuery = "\x1b[?u";
    pub const kittyGraphicsQuery = "\x1b_Gi=31337,s=1,v=1,a=q,t=d,f=24;AAAA\x1b\\\x1b[c";
    pub const sixelGeometryQuery = "\x1b[?2;1;0S";
    pub const cursorPositionRequest = "\x1b[6n";
    pub const explicitWidthQuery = "\x1b]66;w=1; \x1b\\";
    pub const scaledTextQuery = "\x1b]66;s=2; \x1b\\";

    // Focus tracking
    pub const focusSet = "\x1b[?1004h";
    pub const focusReset = "\x1b[?1004l";

    // Sync
    pub const syncSet = "\x1b[?2026h";
    pub const syncReset = "\x1b[?2026l";

    // Unicode
    pub const unicodeSet = "\x1b[?2027h";
    pub const unicodeReset = "\x1b[?2027l";

    // Bracketed paste
    pub const bracketedPasteSet = "\x1b[?2004h";
    pub const bracketedPasteReset = "\x1b[?2004l";

    // Color scheme
    pub const colorSchemeRequest = "\x1b[?996n";
    pub const colorSchemeSet = "\x1b[?2031h";
    pub const colorSchemeReset = "\x1b[?2031l";

    // Key encoding
    pub const csiUPush = "\x1b[>{d}u";
    pub const csiUPop = "\x1b[<u";

    // modifyOtherKeys mode
    pub const modifyOtherKeysSet = "\x1b[>4;1m";
    pub const modifyOtherKeysReset = "\x1b[>4;0m";

    // Movement and erase
    pub const reverseIndex = "\x1bM";
    pub const eraseBelowCursor = "\x1b[J";

    // OSC 0 - Set window title
    pub const setTerminalTitle = "\x1b]0;{s}\x07";

    pub fn setTerminalTitleOutput(writer: anytype, title: []const u8) AnsiError!void {
        writer.print(setTerminalTitle, .{title}) catch return AnsiError.WriteFailed;
    }

    pub fn makeRoomForRendererOutput(writer: anytype, height: u32) AnsiError!void {
        if (height > 1) {
            for (0..height - 1) |_| {
                writer.writeByte('\n') catch return AnsiError.WriteFailed;
            }
        }
    }
};

pub const TextAttributes = struct {
    pub const NONE: u8 = 0;
    pub const BOLD: u8 = 1 << 0;
    pub const DIM: u8 = 1 << 1;
    pub const ITALIC: u8 = 1 << 2;
    pub const UNDERLINE: u8 = 1 << 3;
    pub const BLINK: u8 = 1 << 4;
    pub const INVERSE: u8 = 1 << 5;
    pub const HIDDEN: u8 = 1 << 6;
    pub const STRIKETHROUGH: u8 = 1 << 7;

    pub fn applyAttributesOutputWriter(writer: anytype, attributes: u8) AnsiError!void {
        if (attributes & BOLD != 0) writer.writeAll(ANSI.bold) catch return AnsiError.WriteFailed;
        if (attributes & DIM != 0) writer.writeAll(ANSI.dim) catch return AnsiError.WriteFailed;
        if (attributes & ITALIC != 0) writer.writeAll(ANSI.italic) catch return AnsiError.WriteFailed;
        if (attributes & UNDERLINE != 0) writer.writeAll(ANSI.underline) catch return AnsiError.WriteFailed;
        if (attributes & BLINK != 0) writer.writeAll(ANSI.blink) catch return AnsiError.WriteFailed;
        if (attributes & INVERSE != 0) writer.writeAll(ANSI.inverse) catch return AnsiError.WriteFailed;
        if (attributes & HIDDEN != 0) writer.writeAll(ANSI.hidden) catch return AnsiError.WriteFailed;
        if (attributes & STRIKETHROUGH != 0) writer.writeAll(ANSI.strikethrough) catch return AnsiError.WriteFailed;
    }
};

const HSV_SECTOR_COUNT = 6;
const HUE_SECTOR_DEGREES = 60.0;

pub fn hsvToRgb(h: f32, s: f32, v: f32) RGBA {
    const clamped_h = @mod(h, 360.0);
    const clamped_s = std.math.clamp(s, 0.0, 1.0);
    const clamped_v = std.math.clamp(v, 0.0, 1.0);

    const sector = @as(u8, @intFromFloat(@floor(clamped_h / HUE_SECTOR_DEGREES))) % HSV_SECTOR_COUNT;
    const fractional = clamped_h / HUE_SECTOR_DEGREES - @floor(clamped_h / HUE_SECTOR_DEGREES);

    const p = clamped_v * (1.0 - clamped_s);
    const q = clamped_v * (1.0 - fractional * clamped_s);
    const t = clamped_v * (1.0 - (1.0 - fractional) * clamped_s);

    const rgb = switch (sector) {
        0 => .{ clamped_v, t, p },
        1 => .{ q, clamped_v, p },
        2 => .{ p, clamped_v, t },
        3 => .{ p, q, clamped_v },
        4 => .{ t, p, clamped_v },
        5 => .{ clamped_v, p, q },
        else => unreachable,
    };

    return .{ rgb[0], rgb[1], rgb[2], 1.0 };
}

```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/ansi.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/ansi.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;

pub const RGBA = [4]f32;

pub const AnsiError = error{
    InvalidFormat,
    WriteFailed,
};

pub const ANSI = struct {
    pub const reset = "\x1b[0m";
    pub const clear = "\x1b[2J";
    pub const home = "\x1b[H";
    pub const clearAndHome = "\x1b[H\x1b[2J";
    pub const hideCursor = "\x1b[?25l";
    pub const showCursor = "\x1b[?25h";
    pub const defaultCursorStyle = "\x1b[0 q";
    pub const queryPixelSize = "\x1b[14t";
    pub const nextLine = "\x1b[E";

    // Direct writing to any writer - the most efficient option
    pub fn moveToOutput(writer: anytype, x: u32, y: u32) AnsiError!void {
        writer.print("\x1b[{d};{d}H", .{ y, x }) catch return AnsiError.WriteFailed;
    }

    pub fn fgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        writer.print("\x1b[38;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn bgColorOutput(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        writer.print("\x1b[48;2;{d};{d};{d}m", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    // Text attribute constants
    pub const bold = "\x1b[1m";
    pub const dim = "\x1b[2m";
    pub const italic = "\x1b[3m";
    pub const underline = "\x1b[4m";
    pub const blink = "\x1b[5m";
    pub const inverse = "\x1b[7m";
    pub const hidden = "\x1b[8m";
    pub const strikethrough = "\x1b[9m";

    // Cursor styles
    pub const cursorBlock = "\x1b[2 q";
    pub const cursorBlockBlink = "\x1b[1 q";
    pub const cursorLine = "\x1b[6 q";
    pub const cursorLineBlink = "\x1b[5 q";
    pub const cursorUnderline = "\x1b[4 q";
    pub const cursorUnderlineBlink = "\x1b[3 q";

    pub fn cursorColorOutputWriter(writer: anytype, r: u8, g: u8, b: u8) AnsiError!void {
        writer.print("\x1b]12;#{x:0>2}{x:0>2}{x:0>2}\x07", .{ r, g, b }) catch return AnsiError.WriteFailed;
    }

    pub fn explicitWidthOutput(writer: anytype, width: u32, text: []const u8) AnsiError!void {
        writer.print("\x1b]66;w={d};{s}\x1b\\", .{ width, text }) catch return AnsiError.WriteFailed;
    }

    pub const resetCursorColor = "\x1b]112\x07";
    pub const resetCursorColorFallback = "\x1b]12;default\x07";
    pub const saveCursorState = "\x1b[s";
    pub const restoreCursorState = "\x1b[u";

    pub const switchToAlternateScreen = "\x1b[?1049h";
    pub const switchToMainScreen = "\x1b[?1049l";

    pub const enableMouseTracking = "\x1b[?1000h";
    pub const disableMouseTracking = "\x1b[?1000l";
    pub const enableButtonEventTracking = "\x1b[?1002h";
    pub const disableButtonEventTracking = "\x1b[?1002l";
    pub const enableAnyEventTracking = "\x1b[?1003h";
    pub const disableAnyEventTracking = "\x1b[?1003l";
    pub const enableSGRMouseMode = "\x1b[?1006h";
    pub const disableSGRMouseMode = "\x1b[?1006l";
    pub const mouseSetPixels = "\x1b[?1002;1003;1004;1016h";

    // Terminal capability queries
    pub const primaryDeviceAttrs = "\x1b[c";
    pub const tertiaryDeviceAttrs = "\x1b[=c";
    pub const deviceStatusReport = "\x1b[5n";
    pub const xtversion = "\x1b[>0q";
    pub const decrqmFocus = "\x1b[?1004$p";
    pub const decrqmSgrPixels = "\x1b[?1016$p";
    pub const decrqmBracketedPaste = "\x1b[?2004$p";
    pub const decrqmSync = "\x1b[?2026$p";
    pub const decrqmUnicode = "\x1b[?2027$p";
    pub const decrqmColorScheme = "\x1b[?2031$p";
    pub const csiUQuery = "\x1b[?u";
    pub const kittyGraphicsQuery = "\x1b_Gi=31337,s=1,v=1,a=q,t=d,f=24;AAAA\x1b\\\x1b[c";
    pub const sixelGeometryQuery = "\x1b[?2;1;0S";
    pub const cursorPositionRequest = "\x1b[6n";
    pub const explicitWidthQuery = "\x1b]66;w=1; \x1b\\";
    pub const scaledTextQuery = "\x1b]66;s=2; \x1b\\";

    // Focus tracking
    pub const focusSet = "\x1b[?1004h";
    pub const focusReset = "\x1b[?1004l";

    // Sync
    pub const syncSet = "\x1b[?2026h";
    pub const syncReset = "\x1b[?2026l";

    // Unicode
    pub const unicodeSet = "\x1b[?2027h";
    pub const unicodeReset = "\x1b[?2027l";

    // Bracketed paste
    pub const bracketedPasteSet = "\x1b[?2004h";
    pub const bracketedPasteReset = "\x1b[?2004l";

    // Color scheme
    pub const colorSchemeRequest = "\x1b[?996n";
    pub const colorSchemeSet = "\x1b[?2031h";
    pub const colorSchemeReset = "\x1b[?2031l";

    // Key encoding
    pub const csiUPush = "\x1b[>{d}u";
    pub const csiUPop = "\x1b[<u";

    // modifyOtherKeys mode
    pub const modifyOtherKeysSet = "\x1b[>4;1m";
    pub const modifyOtherKeysReset = "\x1b[>4;0m";

    // Movement and erase
    pub const reverseIndex = "\x1bM";
    pub const eraseBelowCursor = "\x1b[J";

    // OSC 0 - Set window title
    pub const setTerminalTitle = "\x1b]0;{s}\x07";

    pub fn setTerminalTitleOutput(writer: anytype, title: []const u8) AnsiError!void {
        writer.print(setTerminalTitle, .{title}) catch return AnsiError.WriteFailed;
    }

    pub fn makeRoomForRendererOutput(writer: anytype, height: u32) AnsiError!void {
        if (height > 1) {
            for (0..height - 1) |_| {
                writer.writeByte('\n') catch return AnsiError.WriteFailed;
            }
        }
    }
};

pub const TextAttributes = struct {
    pub const NONE: u8 = 0;
    pub const BOLD: u8 = 1 << 0;
    pub const DIM: u8 = 1 << 1;
    pub const ITALIC: u8 = 1 << 2;
    pub const UNDERLINE: u8 = 1 << 3;
    pub const BLINK: u8 = 1 << 4;
    pub const INVERSE: u8 = 1 << 5;
    pub const HIDDEN: u8 = 1 << 6;
    pub const STRIKETHROUGH: u8 = 1 << 7;

    pub fn applyAttributesOutputWriter(writer: anytype, attributes: u8) AnsiError!void {
        if (attributes & BOLD != 0) writer.writeAll(ANSI.bold) catch return AnsiError.WriteFailed;
        if (attributes & DIM != 0) writer.writeAll(ANSI.dim) catch return AnsiError.WriteFailed;
        if (attributes & ITALIC != 0) writer.writeAll(ANSI.italic) catch return AnsiError.WriteFailed;
        if (attributes & UNDERLINE != 0) writer.writeAll(ANSI.underline) catch return AnsiError.WriteFailed;
        if (attributes & BLINK != 0) writer.writeAll(ANSI.blink) catch return AnsiError.WriteFailed;
        if (attributes & INVERSE != 0) writer.writeAll(ANSI.inverse) catch return AnsiError.WriteFailed;
        if (attributes & HIDDEN != 0) writer.writeAll(ANSI.hidden) catch return AnsiError.WriteFailed;
        if (attributes & STRIKETHROUGH != 0) writer.writeAll(ANSI.strikethrough) catch return AnsiError.WriteFailed;
    }
};

const HSV_SECTOR_COUNT = 6;
const HUE_SECTOR_DEGREES = 60.0;

pub fn hsvToRgb(h: f32, s: f32, v: f32) RGBA {
    const clamped_h = @mod(h, 360.0);
    const clamped_s = std.math.clamp(s, 0.0, 1.0);
    const clamped_v = std.math.clamp(v, 0.0, 1.0);

    const sector = @as(u8, @intFromFloat(@floor(clamped_h / HUE_SECTOR_DEGREES))) % HSV_SECTOR_COUNT;
    const fractional = clamped_h / HUE_SECTOR_DEGREES - @floor(clamped_h / HUE_SECTOR_DEGREES);

    const p = clamped_v * (1.0 - clamped_s);
    const q = clamped_v * (1.0 - fractional * clamped_s);
    const t = clamped_v * (1.0 - (1.0 - fractional) * clamped_s);

    const rgb = switch (sector) {
        0 => .{ clamped_v, t, p },
        1 => .{ q, clamped_v, p },
        2 => .{ p, clamped_v, t },
        3 => .{ p, q, clamped_v },
        4 => .{ t, p, clamped_v },
        5 => .{ clamped_v, p, q },
        else => unreachable,
    };

    return .{ rgb[0], rgb[1], rgb[2], 1.0 };
}

```


## Assistant

Excellent! Now let me mark ansi.zig as complete and move on to renderer.zig:Now let me look at the renderer.zig issues. First, let me check the OutputBufferWriter:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (119 - 143)**
Status: Completed

```
    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });


<file-read-info>Read lines 118-26. </file-read-info>
```

## Assistant

Now let me check where it's used:

**Tool Call: Find OutputBufferWriter usage**
Status: Completed

Terminal:
```
118:    const OutputBufferWriter = struct {
549:        var writer = OutputBufferWriter.writer();



```


**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (546 - 560)**
Status: Completed

```
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;


<file-read-info>Read lines 545-16. </file-read-info>
```

## Assistant

I see the issue. The new Writer API in Zig 0.15.1 doesn't use the generic `std.io.Writer` anymore. Let me check the migration patterns for guidance:

**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_PATTERNS.md (381 - 460)**
Status: Completed

````
   ```

4. **Check for Memory Leaks**
   ```bash
   zig build test -Doptimize=Debug
   # Look for "leaked memory" messages
   ```

---

## Real Examples from Codebase

### Example 1: renderer.zig statSamples
```zig
// Before (0.14.1)
const StatSamples = struct {
    drawTime: std.ArrayList(f64),
    // ... more fields
    
    pub fn create(allocator: std.mem.Allocator) !StatSamples {
        return .{
            .drawTime = std.ArrayList(f64).init(allocator),
            // ...
        };
    }
};

// After (0.15.1)
const StatSamples = struct {
    drawTime: std.ArrayListUnmanaged(f64),
    // ... more fields
    
    pub fn create() StatSamples {
        return .{
            .drawTime = .{},
            // ...
        };
    }
    
    pub fn deinit(self: *StatSamples, allocator: std.mem.Allocator) void {
        self.drawTime.deinit(allocator);
        // ...
    }
};
```

### Example 2: ansi.zig format calls
```zig
// Before (0.14.1)
pub fn moveTo(writer: anytype, x: u32, y: u32) AnsiError!void {
    std.fmt.format(writer, "\x1b[{d};{d}H", .{ y + 1, x + 1 }) catch return AnsiError.WriteFailed;
}

// After (0.15.1)
pub fn moveTo(writer: anytype, x: u32, y: u32) AnsiError!void {
    writer.print("\x1b[{d};{d}H", .{ y + 1, x + 1 }) catch return AnsiError.WriteFailed;
}
```

---

---

## Pattern 8: Result Structs with Allocator Field

**New pattern discovered in Session 3**

When migrating structs that contain ArrayListUnmanaged and are used as result types, add an allocator field to enable proper cleanup.

### Before (Zig 0.14.1)
```zig
pub const LineBreakResult = struct {
    breaks: std.ArrayList(LineBreak),

    pub fn init(allocator: std.mem.Allocator) LineBreakResult {
        return .{
            .breaks = std.ArrayList(LineBreak).init(allocator),
        };
    }



<file-read-info>Read lines 380-81. </file-read-info>
````

## Assistant

Let me search for the Writer API pattern:

**Tool Call: Find Writer API migration pattern**
Status: Completed

Terminal:
```
## Pattern 12: BufferedWriter â†’ File.Writer with Buffer (0.15.1 Writer Redesign)

**Context**: Zig 0.15.1 completely redesigned the I/O system. Writers now have built-in buffering instead of using wrapper types.

### Before (Zig 0.14.1)

```zig
const std = @import("std");

pub const MyStruct = struct {
    writer: std.io.BufferedWriter(4096, std.fs.File.Writer),

    pub fn init() !MyStruct {
        const stdout = std.io.getStdOut();
        return .{
            .writer = std.io.BufferedWriter(4096, std.fs.File.Writer){
                .unbuffered_writer = stdout.writer()
            },
        };
    }


```


**Tool Call: Get full Writer API pattern**
Status: Completed

Terminal:
```
## Pattern 12: BufferedWriter â†’ File.Writer with Buffer (0.15.1 Writer Redesign)

**Context**: Zig 0.15.1 completely redesigned the I/O system. Writers now have built-in buffering instead of using wrapper types.

### Before (Zig 0.14.1)

```zig
const std = @import("std");

pub const MyStruct = struct {
    writer: std.io.BufferedWriter(4096, std.fs.File.Writer),

    pub fn init() !MyStruct {
        const stdout = std.io.getStdOut();
        return .{
            .writer = std.io.BufferedWriter(4096, std.fs.File.Writer){
                .unbuffered_writer = stdout.writer()
            },
        };
    }

    pub fn write(self: *MyStruct, data: []const u8) !void {
        try self.writer.writer().writeAll(data);
        try self.writer.flush();
    }
};
```

### After (Zig 0.15.1)

```zig
const std = @import("std");

pub const MyStruct = struct {
    buffer: [4096]u8,
    writer: std.fs.File.Writer,

    pub fn init() !MyStruct {
        var buffer: [4096]u8 = undefined;
        const stdout = std.fs.File.stdout();  // NOTE: No parentheses in 0.14, yes in 0.15.1

        return .{
            .buffer = buffer,
            .writer = stdout.writer(&buffer),
        };
    }

    pub fn write(self: *MyStruct) !void {
        // Access the Writer interface
        const writer = &self.writer.interface;
        try writer.writeAll(data);
        try writer.flush();
    }
};
```

### Key Changes

1. **Type change**: `std.io.BufferedWriter(N, T)` â†’ `std.fs.File.Writer`
2. **Buffer field**: Add explicit `buffer: [N]u8` to struct
3. **Initialization**: `file.writer(&buffer)` instead of BufferedWriter struct literal

```


## Assistant

Now I understand. The OutputBufferWriter is a custom implementation. Looking at the error, the issue is that `std.io.Writer` constructor signature changed. Let me check what the new approach should be. Actually, looking at the code, this is a custom writer that writes to a local buffer. Let me see if we can simplify this or use the new API.

Let me first check where file.writer() is being called:

**Tool Call: Find file.writer() calls**
Status: Completed

Terminal:
```
797:        const writer = file.writer();
823:        const writer = file.writer();
864:        const writer = file.writer();


```


**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (791 - 810)**
Status: Completed

```
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.writeByte(char) catch return;
            }
            writer.writeByte('\n') catch return;
        }
    }


<file-read-info>Read lines 790-21. </file-read-info>
```

## Assistant

I see. These are debug dump functions. In Zig 0.15.1, `file.writer()` requires a buffer parameter. Let me fix these:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (786 - 815)**
Status: Completed

```
        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.writeByte(char) catch return;
            }
            writer.writeByte('\n') catch return;
        }
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,


<file-read-info>Read lines 785-31. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.writeByte(' ') catch return;
                }
            }
            writer.writeByte('\n') catch return;
        }
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.writeAll("(no output rendered yet)\n") catch return;
        }

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now let me fix the other two file.writer() calls:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (816 - 845)**
Status: Completed

```
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.writeAll(utf8Buf[0..len]) catch return;
                    }


<file-read-info>Read lines 815-31. </file-read-info>
```

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (846 - 875)**
Status: Completed

```
                } else {
                    writer.writeByte(' ') catch return;
                }
            }
            writer.writeByte('\n') catch return;
        }
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;



<file-read-info>Read lines 845-31. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.writeByte(' ') catch return;
                }
            }
            writer.writeByte('\n') catch return;
        }
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.writeAll("(no output rendered yet)\n") catch return;
        }

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now I need to update all the writer calls in this function to use writer.interface:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (831 - 855)**
Status: Completed

```

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.writeByte(' ') catch return;
                }
            }
            writer.writeByte('\n') catch return;
        }
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {


<file-read-info>Read lines 830-26. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.writeAll("(no output rendered yet)\n") catch return;
        }

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now let me fix the third file.writer() call:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (863 - 882)**
Status: Completed

```
        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        const writer = file.writer();

        writer.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.writeAll("(no output rendered yet)\n") catch return;
        }


<file-read-info>Read lines 862-21. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

I see there are more writer calls below. Let me read more:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (881 - 890)**
Status: Completed

```
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.writeAll("\n================\n") catch return;
        writer.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
    }



<file-read-info>Read lines 880-11. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    const OutputBufferWriter = struct {
        pub fn write(_: void, data: []const u8) !usize {
            const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
            const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

            if (bufferLen.* + data.len > buffer.len) {
                // TODO: Resize buffer when necessary
                return error.BufferFull;
            }

            @memcpy(buffer.*[bufferLen.*..][0..data.len], data);
            bufferLen.* += data.len;

            return data.len;
        }

        pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
            return .{ .context = {} };
        }
    };

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Good! Now I need to fix the OutputBufferWriter. Let me understand the new Writer API better. The issue is that `std.io.Writer` is no longer a generic type. Let me check if we can simplify this custom writer or adapt it to the new API. Let me look at how it's used:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (546 - 605)**
Status: Completed

```
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;



<file-read-info>Read lines 545-61. </file-read-info>
```

## Assistant

I see the issue. The `OutputBufferWriter` is a custom writer that writes to a module-level buffer. The new Writer API doesn't support the old generic pattern. Let me check what the new approach should be. Actually, looking at this, I think we can remove the custom writer entirely and just write directly to the buffer. Let me check the whole render function to understand the pattern:

**Tool Call: Find direct buffer writes**
Status: Completed

Terminal:
```
510:            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};




```


## Assistant

Looking at this, the OutputBufferWriter writes to `outputBuffer` and later that buffer is flushed to stdout. The simplest solution is to use `std.io.FixedBufferStream` which provides a writer interface. Let me try that approach:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;
        
        var stream = std.io.fixedBufferStream(buffer.*);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var writer = OutputBufferWriter.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now I need to update the usage of OutputBufferWriter.writer() to use the new approach:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;
        
        var stream = std.io.fixedBufferStream(buffer.*);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var stream = getOutputBufferWriter();
        const writer = stream.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now I need to add the call to update the buffer length at the end of the render function. Let me find where the render function ends:

**Tool Call: Find render function**
Status: Completed

Terminal:
```
471:    pub fn render(self: *CliRenderer, force: bool) void {




```


## Assistant

Let me find where the writer is last used before flushing to stdout:

**Tool Call: Find end of render function**
Status: Completed

Terminal:
```
471:     pub fn render(self: *CliRenderer, force: bool) void {





```


**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (491 - 520)**
Status: Completed

```
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);


<file-read-info>Read lines 490-31. </file-read-info>
```

## Assistant

I need to find where the writer finishes writing before line 490. Let me search backwards:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (461 - 495)**
Status: Completed

```
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;


<file-read-info>Read lines 460-36. </file-read-info>
```

## Assistant

Let me search for where prepareRenderFrame is defined and where the writer is done:

**Tool Call: Find prepareRenderFrame function**
Status: Completed

Terminal:
```
532:    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {




```


## Assistant

Let me read the end of prepareRenderFrame to see where the writer finishes:

**Tool Call: Find end of prepareRenderFrame**
Status: Completed

Terminal:
```
532:     fn prepareRenderFrame(self: *CliRenderer, force: bool) void {





```


## Assistant

Let me try a different approach - let me search for "writer.writeAll" in the render-related section:

**Tool Call: Find writer usage in render**
Status: Completed

Terminal:
```
280:        writer.writeAll(ansi.ANSI.saveCursorState) catch {};
545:        writer.writeAll(ansi.ANSI.syncSet) catch {};
546:        writer.writeAll(ansi.ANSI.hideCursor) catch {};
577:                            writer.writeAll(ansi.ANSI.reset) catch {};
593:                        writer.writeAll(ansi.ANSI.reset) catch {};
618:                        writer.writeAll("\x1b[49m") catch {};
639:                            writer.writeAll(bytes) catch {};
644:                    writer.writeByte(' ') catch {};
647:                    writer.writeAll(utf8Buf[0..len]) catch {};
669:        writer.writeAll(ansi.ANSI.reset) catch {};
713:                writer.writeAll(cursorStyleCode) catch {};
718:            writer.writeAll(ansi.ANSI.showCursor) catch {};
720:            writer.writeAll(ansi.ANSI.hideCursor) catch {};
726:        writer.writeAll(ansi.ANSI.syncReset) catch {};
903:        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

```


## Assistant

Good! Line 726 seems to be near the end. Let me read that section:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (721 - 735)**
Status: Completed

```
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};


<file-read-info>Read lines 720-16. </file-read-info>
```

## Assistant

Perfect! I need to add the updateOutputBufferLen call right after line 726 (after the last writer.writeAll). Let me do that:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

        var stream = std.io.fixedBufferStream(buffer.*);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var stream = getOutputBufferWriter();
        const writer = stream.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        // Update the output buffer length after all writes
        updateOutputBufferLen(&stream);

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Excellent! Now let me try compiling to see if there are any remaining issues:

**Tool Call: Compile and check for errors**
Status: Completed

Terminal:
```
install
+- install opentui
   +- compile lib opentui Debug x86_64-macos 4 errors
/Users/sean/.zvm/0.15.1/lib/std/Io/fixed_buffer_stream.zig:116:17: error: invalid type given to fixedBufferStream
        else => @compileError("invalid type given to fixedBufferStream"),
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/Io/fixed_buffer_stream.zig:97:66: note: called at comptime here
pub fn fixedBufferStream(buffer: anytype) FixedBufferStream(Slice(@TypeOf(buffer))) {
                                                            ~~~~~^~~~~~~~~~~~~~~~~
renderer.zig:122:46: note: generic function instantiated here
        var stream = std.io.fixedBufferStream(buffer.*);
                     ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
referenced by:
    prepareRenderFrame: renderer.zig:542:43
    render: renderer.zig:479:32
    6 reference(s) hidden; use '-freference-trace=8' to see all references
renderer.zig:803:33: error: expected type '*Io.Writer', found '*const Io.Writer'
                writer.interface.writeByte(char) catch return;
                ~~~~~~~~~~~~~~~~^~~~~~~~~~
renderer.zig:803:33: note: cast discards const qualifier
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:724:21: note: parameter type declared here
pub fn writeByte(w: *Writer, byte: u8) Error!void {
                    ^~~~~~~
renderer.zig:825:25: error: expected type '*Io.Writer', found '*const Io.Writer'
        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        ~~~~~~~~~~~~~~~~^~~~~~
renderer.zig:825:25: note: cast discards const qualifier
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:593:17: note: parameter type declared here
pub fn print(w: *Writer, comptime fmt: []const u8, args: anytype) Error!void {
                ^~~~~~~
renderer.zig:868:25: error: expected type '*Io.Writer', found '*const Io.Writer'
        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        ~~~~~~~~~~~~~~~~^~~~~~
renderer.zig:868:25: note: cast discards const qualifier
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:593:17: note: parameter type declared here
pub fn print(w: *Writer, comptime fmt: []const u8, args: anytype) Error!void {
                ^~~~~~~
error: the following command failed with 4 compilation errors:
/Users/sean/.zvm/0.15.1/zig build-lib -ODebug -target x86_64-macos -mcpu baseline --dep uucode -Mroot=/Users/sean/code/opentui/packages/core/src/zig/lib.zig -ODebug -target x86_64-macos -mcpu baseline --dep types.zig --dep config.zig --dep types.x.zig --dep tables --dep get.zig -Muucode=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/root.zig -ODebug -target x86_64-macos -mcpu baseline --dep config.zig --dep get.zig -Mtypes.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/types.zig -ODebug -target x86_64-macos -mcpu baseline --dep types.zig -Mconfig.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/config.zig -ODebug -target x86_64-macos -mcpu baseline --dep config.x.zig -Mtypes.x.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/x/types.x.zig -ODebug -target x86_64-macos -mcpu baseline --dep types.zig --dep types.x.zig --dep config.zig --dep build_config -Mtables=.zig-cache/o/5dc1cf3f99978df803de63330de5b47e/tables.zig -ODebug -target x86_64-macos -mcpu baseline --dep types.zig --dep tables -Mget.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/get.zig -ODebug -target x86_64-macos -mcpu baseline --dep types.x.zig --dep types.zig --dep config.zig -Mconfig.x.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/x/config.x.zig -target x86_64-macos -mcpu baseline --dep types.zig --dep config.zig --dep types.x.zig --dep config.x.zig -Mbuild_config=.zig-cache/o/293f946a3807447769f740906ec01801/build_config.zig --cache-dir .zig-cache --global-cache-dir /Users/sean/.cache/zig --name opentui -dynamic -install_name @rpath/libopentui.dylib --zig-lib-dir /Users/sean/.zvm/0.15.1/lib/ --listen=-
install
+- install opentui
   +- compile lib opentui Debug x86_64-windows 4 errors
/Users/sean/.zvm/0.15.1/lib/std/Io/fixed_buffer_stream.zig:116:17: error: invalid type given to fixedBufferStream
        else => @compileError("invalid type given to fixedBufferStream"),
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/sean/.zvm/0.15.1/lib/std/Io/fixed_buffer_stream.zig:97:66: note: called at comptime here
pub fn fixedBufferStream(buffer: anytype) FixedBufferStream(Slice(@TypeOf(buffer))) {
                                                            ~~~~~^~~~~~~~~~~~~~~~~
renderer.zig:122:46: note: generic function instantiated here
        var stream = std.io.fixedBufferStream(buffer.*);
                     ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
referenced by:
    prepareRenderFrame: renderer.zig:542:43
    render: renderer.zig:479:32
    6 reference(s) hidden; use '-freference-trace=8' to see all references
renderer.zig:803:33: error: expected type '*Io.Writer', found '*const Io.Writer'
                writer.interface.writeByte(char) catch return;
                ~~~~~~~~~~~~~~~~^~~~~~~~~~
renderer.zig:803:33: note: cast discards const qualifier
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:724:21: note: parameter type declared here
pub fn writeByte(w: *Writer, byte: u8) Error!void {
                    ^~~~~~~
renderer.zig:825:25: error: expected type '*Io.Writer', found '*const Io.Writer'
        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        ~~~~~~~~~~~~~~~~^~~~~~
renderer.zig:825:25: note: cast discards const qualifier
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:593:17: note: parameter type declared here
pub fn print(w: *Writer, comptime fmt: []const u8, args: anytype) Error!void {
                ^~~~~~~
renderer.zig:868:25: error: expected type '*Io.Writer', found '*const Io.Writer'
        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        ~~~~~~~~~~~~~~~~^~~~~~
renderer.zig:868:25: note: cast discards const qualifier
/Users/sean/.zvm/0.15.1/lib/std/Io/Writer.zig:593:17: note: parameter type declared here
pub fn print(w: *Writer, comptime fmt: []const u8, args: anytype) Error!void {
                ^~~~~~~
error: the following command failed with 4 compilation errors:
/Users/sean/.zvm/0.15.1/zig build-lib -ODebug -target x86_64-windows -mcpu baseline --dep uucode -Mroot=/Users/sean/code/opentui/packages/core/src/zig/lib.zig -ODebug -target x86_64-windows -mcpu baseline --dep types.zig --dep config.zig --dep types.x.zig --dep tables --dep get.zig -Muucode=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/root.zig -ODebug -target x86_64-windows -mcpu baseline --dep config.zig --dep get.zig -Mtypes.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/types.zig -ODebug -target x86_64-windows -mcpu baseline --dep types.zig -Mconfig.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/config.zig -ODebug -target x86_64-windows -mcpu baseline --dep config.x.zig -Mtypes.x.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/x/types.x.zig -ODebug -target x86_64-windows -mcpu baseline --dep types.zig --dep types.x.zig --dep config.zig --dep build_config -Mtables=.zig-cache/o/5dc1cf3f99978df803de63330de5b47e/tables.zig -ODebug -target x86_64-windows -mcpu baseline --dep types.zig --dep tables -Mget.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/get.zig -ODebug -target x86_64-windows -mcpu baseline --dep types.x.zig --dep types.zig --dep config.zig -Mconfig.x.zig=/Users/sean/.cache/zig/p/uucode-0.1.0-ZZjBPqVUSAB2pkeeLBktyBMZf8yV9kM441GTOxXmxwcq/src/x/config.x.zig -target x86_64-windows -mcpu baseline --dep types.zig --dep config.zig --dep types.x.zig --dep config.x.zig -Mbuild_config=.zig-cache/o/293f946a3807447769f740906ec01801/build_config.zig -femit-implib --cache-dir .zig-cache --global-cache-dir /Users/sean/.cache/zig --name opentui -dynamic --zig-lib-dir /Users/sean/.zvm/0.15.1/lib/ --listen=-
install
+- install opentui

```


## Assistant

Good progress! Two issues:

1. `fixedBufferStream` doesn't work with `buffer.*` - it needs a slice, not an array
2. `writer.interface` returns `*const Writer` but we need `*Writer`

Let me fix these:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Failed

```
The provided `old_string` does not appear in the file: "    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;
        
        var stream = std.io.fixedBufferStream(buffer.*);
        stream.pos = bufferLen.*;
        return stream;
    }".

No edits were applied.
```

## Assistant

Let me read the current state:

**Tool Call: Read /Users/sean/code/opentui/packages/core/src/zig/renderer.zig (118 - 132)**
Status: Completed

```

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

        var stream = std.io.fixedBufferStream(buffer.*);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }



<file-read-info>Read lines 117-16. </file-read-info>
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

        var stream = std.io.fixedBufferStream(buffer);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var stream = getOutputBufferWriter();
        const writer = stream.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        // Update the output buffer length after all writes
        updateOutputBufferLen(&stream);

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        const writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now I need to fix the const Writer issue. The problem is that `writer.interface` returns a const pointer, but we need a mutable one. Let me use `&writer.interface` instead:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

        var stream = std.io.fixedBufferStream(buffer);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var stream = getOutputBufferWriter();
        const writer = stream.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        // Update the output buffer length after all writes
        updateOutputBufferLen(&stream);

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        var writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

        var stream = std.io.fixedBufferStream(buffer);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var stream = getOutputBufferWriter();
        const writer = stream.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        // Update the output buffer length after all writes
        updateOutputBufferLen(&stream);

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        var writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        var writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        const writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/src/zig/renderer.zig`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/src/zig/renderer.zig
```
const std = @import("std");
const Allocator = std.mem.Allocator;
const ansi = @import("ansi.zig");
const buf = @import("buffer.zig");
const gp = @import("grapheme.zig");
const Terminal = @import("terminal.zig");
const logger = @import("logger.zig");

pub const RGBA = ansi.RGBA;
pub const OptimizedBuffer = buf.OptimizedBuffer;
pub const TextAttributes = ansi.TextAttributes;
pub const CursorStyle = Terminal.CursorStyle;

const CLEAR_CHAR = '\u{0a00}';
const MAX_STAT_SAMPLES = 30;
const STAT_SAMPLE_CAPACITY = 30;

const COLOR_EPSILON_DEFAULT: f32 = 0.00001;
const OUTPUT_BUFFER_SIZE = 1024 * 1024 * 2; // 2MB

pub const RendererError = error{
    OutOfMemory,
    InvalidDimensions,
    ThreadingFailed,
    WriteFailed,
};

fn rgbaComponentToU8(component: f32) u8 {
    if (!std.math.isFinite(component)) return 0;

    const clamped = std.math.clamp(component, 0.0, 1.0);
    return @intFromFloat(@round(clamped * 255.0));
}

pub const DebugOverlayCorner = enum {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight,
};

pub const CliRenderer = struct {
    width: u32,
    height: u32,
    currentRenderBuffer: *OptimizedBuffer,
    nextRenderBuffer: *OptimizedBuffer,
    pool: *gp.GraphemePool,
    backgroundColor: RGBA,
    renderOffset: u32,
    terminal: Terminal,
    testing: bool = false,
    useAlternateScreen: bool = true,
    useKittyKeyboard: bool = true,
    terminalSetup: bool = false,

    renderStats: struct {
        lastFrameTime: f64,
        averageFrameTime: f64,
        frameCount: u64,
        fps: u32,
        cellsUpdated: u32,
        renderTime: ?f64,
        overallFrameTime: ?f64,
        bufferResetTime: ?f64,
        stdoutWriteTime: ?f64,
        heapUsed: u32,
        heapTotal: u32,
        arrayBuffers: u32,
        frameCallbackTime: ?f64,
    },
    statSamples: struct {
        lastFrameTime: std.ArrayList(f64),
        renderTime: std.ArrayList(f64),
        overallFrameTime: std.ArrayList(f64),
        bufferResetTime: std.ArrayList(f64),
        stdoutWriteTime: std.ArrayList(f64),
        cellsUpdated: std.ArrayList(u32),
        frameCallbackTime: std.ArrayList(f64),
    },
    lastRenderTime: i64,
    allocator: Allocator,
    renderThread: ?std.Thread = null,
    stdout_buffer: [4096]u8,
    stdoutWriter: std.fs.File.Writer,
    debugOverlay: struct {
        enabled: bool,
        corner: DebugOverlayCorner,
    } = .{
        .enabled = false,
        .corner = .bottomRight,
    },
    // Threading
    useThread: bool = false,
    renderMutex: std.Thread.Mutex = .{},
    renderCondition: std.Thread.Condition = .{},
    renderRequested: bool = false,
    shouldTerminate: bool = false,
    renderInProgress: bool = false,
    currentOutputBuffer: []u8 = &[_]u8{},
    currentOutputLen: usize = 0,

    currentHitGrid: []u32,
    nextHitGrid: []u32,
    hitGridWidth: u32,
    hitGridHeight: u32,

    lastCursorStyleTag: ?u8 = null,
    lastCursorBlinking: ?bool = null,
    lastCursorColorRGB: ?[3]u8 = null,

    // Preallocated output buffer
    var outputBuffer: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferLen: usize = 0;
    var outputBufferB: [OUTPUT_BUFFER_SIZE]u8 = undefined;
    var outputBufferBLen: usize = 0;
    var activeBuffer: enum { A, B } = .A;

    fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        const buffer = if (activeBuffer == .A) &outputBuffer else &outputBufferB;

        var stream = std.io.fixedBufferStream(buffer);
        stream.pos = bufferLen.*;
        return stream;
    }

    fn updateOutputBufferLen(stream: *std.io.FixedBufferStream([]u8)) void {
        const bufferLen = if (activeBuffer == .A) &outputBufferLen else &outputBufferBLen;
        bufferLen.* = stream.pos;
    }

    pub fn create(allocator: Allocator, width: u32, height: u32, pool: *gp.GraphemePool, testing: bool) !*CliRenderer {
        const self = try allocator.create(CliRenderer);

        const currentBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "current buffer" });
        const nextBuffer = try OptimizedBuffer.init(allocator, width, height, .{ .pool = pool, .width_method = .unicode, .id = "next buffer" });

        var stdout_buffer: [4096]u8 = undefined;
        const stdoutWriter = if (testing) blk: {
            // In testing mode, use /dev/null to discard output
            const devnull = std.fs.openFileAbsolute("/dev/null", .{ .mode = .write_only }) catch {
                // Fallback to stdout if /dev/null can't be opened
                logger.warn("Failed to open /dev/null, falling back to stdout\n", .{});
                break :blk std.fs.File.stdout().writer(&stdout_buffer);
            };
            break :blk devnull.writer(&stdout_buffer);
        } else blk: {
            const stdout = std.fs.File.stdout();
            break :blk stdout.writer(&stdout_buffer);
        };

        // stat sample arrays
        var lastFrameTime: std.ArrayList(f64) = .{};
        var renderTime: std.ArrayList(f64) = .{};
        var overallFrameTime: std.ArrayList(f64) = .{};
        var bufferResetTime: std.ArrayList(f64) = .{};
        var stdoutWriteTime: std.ArrayList(f64) = .{};
        var cellsUpdated: std.ArrayList(u32) = .{};
        var frameCallbackTimes: std.ArrayList(f64) = .{};

        try lastFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try renderTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try overallFrameTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try bufferResetTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try stdoutWriteTime.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try cellsUpdated.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);
        try frameCallbackTimes.ensureTotalCapacity(allocator, STAT_SAMPLE_CAPACITY);

        const hitGridSize = width * height;
        const currentHitGrid = try allocator.alloc(u32, hitGridSize);
        const nextHitGrid = try allocator.alloc(u32, hitGridSize);
        @memset(currentHitGrid, 0); // Initialize with 0 (no renderable)
        @memset(nextHitGrid, 0);

        self.* = .{
            .width = width,
            .height = height,
            .currentRenderBuffer = currentBuffer,
            .nextRenderBuffer = nextBuffer,
            .pool = pool,
            .backgroundColor = .{ 0.0, 0.0, 0.0, 0.0 },
            .renderOffset = 0,
            .terminal = Terminal.init(.{}),
            .testing = testing,
            .lastCursorStyleTag = null,
            .lastCursorBlinking = null,
            .lastCursorColorRGB = null,

            .renderStats = .{
                .lastFrameTime = 0,
                .averageFrameTime = 0,
                .frameCount = 0,
                .fps = 0,
                .cellsUpdated = 0,
                .renderTime = null,
                .overallFrameTime = null,
                .bufferResetTime = null,
                .stdoutWriteTime = null,
                .heapUsed = 0,
                .heapTotal = 0,
                .arrayBuffers = 0,
                .frameCallbackTime = null,
            },
            .statSamples = .{
                .lastFrameTime = lastFrameTime,
                .renderTime = renderTime,
                .overallFrameTime = overallFrameTime,
                .bufferResetTime = bufferResetTime,
                .stdoutWriteTime = stdoutWriteTime,
                .cellsUpdated = cellsUpdated,
                .frameCallbackTime = frameCallbackTimes,
            },
            .lastRenderTime = std.time.microTimestamp(),
            .allocator = allocator,
            .stdout_buffer = stdout_buffer,
            .stdoutWriter = stdoutWriter,
            .currentHitGrid = currentHitGrid,
            .nextHitGrid = nextHitGrid,
            .hitGridWidth = width,
            .hitGridHeight = height,
        };

        try currentBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, CLEAR_CHAR);
        try nextBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        return self;
    }

    pub fn destroy(self: *CliRenderer) void {
        self.renderMutex.lock();
        while (self.renderInProgress) {
            self.renderCondition.wait(&self.renderMutex);
        }

        self.shouldTerminate = true;
        self.renderRequested = true;
        self.renderCondition.signal();
        self.renderMutex.unlock();

        if (self.renderThread) |thread| {
            thread.join();
        }

        self.performShutdownSequence();

        self.currentRenderBuffer.deinit();
        self.nextRenderBuffer.deinit();

        // Free stat sample arrays
        self.statSamples.lastFrameTime.deinit(self.allocator);
        self.statSamples.renderTime.deinit(self.allocator);
        self.statSamples.overallFrameTime.deinit(self.allocator);
        self.statSamples.bufferResetTime.deinit(self.allocator);
        self.statSamples.stdoutWriteTime.deinit(self.allocator);
        self.statSamples.cellsUpdated.deinit(self.allocator);
        self.statSamples.frameCallbackTime.deinit(self.allocator);

        self.allocator.free(self.currentHitGrid);
        self.allocator.free(self.nextHitGrid);

        self.allocator.destroy(self);
    }

    pub fn setupTerminal(self: *CliRenderer, useAlternateScreen: bool) void {
        self.useAlternateScreen = useAlternateScreen;
        self.terminalSetup = true;

        const writer = &self.stdoutWriter.interface;

        self.terminal.queryTerminalSend(writer) catch {
            logger.warn("Failed to query terminal capabilities", .{});
        };

        self.setupTerminalWithoutDetection(useAlternateScreen);
    }

    fn setupTerminalWithoutDetection(self: *CliRenderer, useAlternateScreen: bool) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.saveCursorState) catch {};

        if (useAlternateScreen) {
            self.terminal.enterAltScreen(writer) catch {};
        } else {
            ansi.ANSI.makeRoomForRendererOutput(writer, @max(self.height, 1)) catch {};
        }

        self.terminal.setCursorPosition(1, 1, false);
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn suspendRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.performShutdownSequence();
    }

    pub fn resumeRenderer(self: *CliRenderer) void {
        if (!self.terminalSetup) return;
        self.setupTerminalWithoutDetection(self.useAlternateScreen);
    }

    pub fn performShutdownSequence(self: *CliRenderer) void {
        if (!self.terminalSetup) return;

        const direct = &self.stdoutWriter.interface;
        self.terminal.resetState(direct) catch {
            logger.warn("Failed to reset terminal state", .{});
        };

        if (self.useAlternateScreen) {
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset == 0) {
            direct.writeAll("\x1b[H\x1b[J") catch {};
            self.stdoutWriter.interface.flush() catch {};
        } else if (self.renderOffset > 0) {
            // Currently still handled in typescript
            // const consoleEndLine = self.height - self.renderOffset;
            // ansi.ANSI.moveToOutput(direct, 1, consoleEndLine) catch {};
        }

        // NOTE: This messes up state after shutdown, but might be necessary for windows?
        // direct.writeAll(ansi.ANSI.restoreCursorState) catch {};

        direct.writeAll(ansi.ANSI.resetCursorColorFallback) catch {};
        direct.writeAll(ansi.ANSI.resetCursorColor) catch {};
        direct.writeAll(ansi.ANSI.defaultCursorStyle) catch {};
        // Workaround for Ghostty not showing the cursor after shutdown for some reason
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
        direct.writeAll(ansi.ANSI.showCursor) catch {};
        self.stdoutWriter.interface.flush() catch {};
        std.Thread.sleep(10 * std.time.ns_per_ms);
    }

    fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
        samples.append(allocator, value) catch return;

        if (samples.items.len > MAX_STAT_SAMPLES) {
            _ = samples.orderedRemove(0);
        }
    }

    fn getStatAverage(comptime T: type, samples: *const std.ArrayList(T)) T {
        if (samples.items.len == 0) {
            return 0;
        }

        var sum: T = 0;
        for (samples.items) |value| {
            sum += value;
        }

        if (@typeInfo(T) == .float) {
            return sum / @as(T, @floatFromInt(samples.items.len));
        } else {
            return sum / @as(T, @intCast(samples.items.len));
        }
    }

    pub fn setUseThread(self: *CliRenderer, useThread: bool) void {
        if (self.useThread == useThread) return;

        if (useThread) {
            if (self.renderThread == null) {
                self.renderThread = std.Thread.spawn(.{}, renderThreadFn, .{self}) catch |err| {
                    std.log.warn("Failed to spawn render thread: {}, falling back to non-threaded mode", .{err});
                    self.useThread = false;
                    return;
                };
            }
        } else {
            if (self.renderThread) |thread| {
                thread.join();
                self.renderThread = null;
            }
        }

        self.useThread = useThread;
    }

    pub fn updateStats(self: *CliRenderer, time: f64, fps: u32, frameCallbackTime: f64) void {
        self.renderStats.overallFrameTime = time;
        self.renderStats.fps = fps;
        self.renderStats.frameCallbackTime = frameCallbackTime;

        addStatSample(f64, self.allocator, &self.statSamples.overallFrameTime, time);
        addStatSample(f64, self.allocator, &self.statSamples.frameCallbackTime, frameCallbackTime);
    }

    pub fn updateMemoryStats(self: *CliRenderer, heapUsed: u32, heapTotal: u32, arrayBuffers: u32) void {
        self.renderStats.heapUsed = heapUsed;
        self.renderStats.heapTotal = heapTotal;
        self.renderStats.arrayBuffers = arrayBuffers;
    }

    pub fn resize(self: *CliRenderer, width: u32, height: u32) !void {
        if (self.width == width and self.height == height) return;

        self.width = width;
        self.height = height;

        try self.currentRenderBuffer.resize(width, height);
        try self.nextRenderBuffer.resize(width, height);

        try self.currentRenderBuffer.clear(.{ 0.0, 0.0, 0.0, 1.0 }, CLEAR_CHAR);
        try self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null);

        const newHitGridSize = width * height;
        const currentHitGridSize = self.hitGridWidth * self.hitGridHeight;
        if (newHitGridSize > currentHitGridSize) {
            const newCurrentHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            const newNextHitGrid = try self.allocator.alloc(u32, newHitGridSize);
            @memset(newCurrentHitGrid, 0);
            @memset(newNextHitGrid, 0);

            self.allocator.free(self.currentHitGrid);
            self.allocator.free(self.nextHitGrid);
            self.currentHitGrid = newCurrentHitGrid;
            self.nextHitGrid = newNextHitGrid;
            self.hitGridWidth = width;
            self.hitGridHeight = height;
        }

        const cursor = self.terminal.getCursorPosition();
        self.terminal.setCursorPosition(@min(cursor.x, width), @min(cursor.y, height), cursor.visible);
    }

    pub fn setBackgroundColor(self: *CliRenderer, rgba: RGBA) void {
        self.backgroundColor = rgba;
    }

    pub fn setRenderOffset(self: *CliRenderer, offset: u32) void {
        self.renderOffset = offset;
    }

    fn renderThreadFn(self: *CliRenderer) void {
        while (true) {
            self.renderMutex.lock();
            while (!self.renderRequested and !self.shouldTerminate) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (self.shouldTerminate and !self.renderRequested) {
                self.renderMutex.unlock();
                break;
            }

            self.renderRequested = false;

            const outputData = self.currentOutputBuffer;
            const outputLen = self.currentOutputLen;

            const writeStart = std.time.microTimestamp();
            if (outputLen > 0) {
                self.stdoutWriter.interface.writeAll(outputData[0..outputLen]) catch {};
                self.stdoutWriter.interface.flush() catch {};
            }

            // Signal that rendering is complete
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
            self.renderInProgress = false;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        }
    }

    // Render once with current state
    pub fn render(self: *CliRenderer, force: bool) void {
        const now = std.time.microTimestamp();
        const deltaTimeMs = @as(f64, @floatFromInt(now - self.lastRenderTime));
        const deltaTime = deltaTimeMs / 1000.0; // Convert to seconds

        self.lastRenderTime = now;
        self.renderDebugOverlay();

        self.prepareRenderFrame(force);

        if (self.useThread) {
            self.renderMutex.lock();
            while (self.renderInProgress) {
                self.renderCondition.wait(&self.renderMutex);
            }

            if (activeBuffer == .A) {
                activeBuffer = .B;
                self.currentOutputBuffer = &outputBuffer;
                self.currentOutputLen = outputBufferLen;
            } else {
                activeBuffer = .A;
                self.currentOutputBuffer = &outputBufferB;
                self.currentOutputLen = outputBufferBLen;
            }

            self.renderRequested = true;
            self.renderInProgress = true;
            self.renderCondition.signal();
            self.renderMutex.unlock();
        } else {
            const writeStart = std.time.microTimestamp();
            self.stdoutWriter.interface.writeAll(outputBuffer[0..outputBufferLen]) catch {};
            self.stdoutWriter.interface.flush() catch {};
            self.renderStats.stdoutWriteTime = @as(f64, @floatFromInt(std.time.microTimestamp() - writeStart));
        }

        self.renderStats.lastFrameTime = deltaTime * 1000.0;
        self.renderStats.frameCount += 1;

        addStatSample(f64, self.allocator, &self.statSamples.lastFrameTime, deltaTime * 1000.0);
        if (self.renderStats.renderTime) |rt| {
            addStatSample(f64, self.allocator, &self.statSamples.renderTime, rt);
        }
        if (self.renderStats.bufferResetTime) |brt| {
            addStatSample(f64, self.allocator, &self.statSamples.bufferResetTime, brt);
        }
        if (self.renderStats.stdoutWriteTime) |swt| {
            addStatSample(f64, self.allocator, &self.statSamples.stdoutWriteTime, swt);
        }
        addStatSample(u32, self.allocator, &self.statSamples.cellsUpdated, self.renderStats.cellsUpdated);
    }

    pub fn getNextBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.nextRenderBuffer;
    }

    pub fn getCurrentBuffer(self: *CliRenderer) *OptimizedBuffer {
        return self.currentRenderBuffer;
    }

    fn prepareRenderFrame(self: *CliRenderer, force: bool) void {
        const renderStartTime = std.time.microTimestamp();
        var cellsUpdated: u32 = 0;

        if (activeBuffer == .A) {
            outputBufferLen = 0;
        } else {
            outputBufferBLen = 0;
        }

        var stream = getOutputBufferWriter();
        const writer = stream.writer();

        writer.writeAll(ansi.ANSI.syncSet) catch {};
        writer.writeAll(ansi.ANSI.hideCursor) catch {};

        var currentFg: ?RGBA = null;
        var currentBg: ?RGBA = null;
        var currentAttributes: i16 = -1;
        var utf8Buf: [4]u8 = undefined;

        const colorEpsilon: f32 = COLOR_EPSILON_DEFAULT;

        for (0..self.height) |uy| {
            const y = @as(u32, @intCast(uy));

            var runStart: i64 = -1;
            var runLength: u32 = 0;

            for (0..self.width) |ux| {
                const x = @as(u32, @intCast(ux));
                const currentCell = self.currentRenderBuffer.get(x, y);
                const nextCell = self.nextRenderBuffer.get(x, y);

                if (currentCell == null or nextCell == null) continue;

                if (!force) {
                    const charEqual = currentCell.?.char == nextCell.?.char;
                    const attrEqual = currentCell.?.attributes == nextCell.?.attributes;

                    if (charEqual and attrEqual and
                        buf.rgbaEqual(currentCell.?.fg, nextCell.?.fg, colorEpsilon) and
                        buf.rgbaEqual(currentCell.?.bg, nextCell.?.bg, colorEpsilon))
                    {
                        if (runLength > 0) {
                            writer.writeAll(ansi.ANSI.reset) catch {};
                            runStart = -1;
                            runLength = 0;
                        }
                        continue;
                    }
                }

                const cell = nextCell.?;

                const fgMatch = currentFg != null and buf.rgbaEqual(currentFg.?, cell.fg, colorEpsilon);
                const bgMatch = currentBg != null and buf.rgbaEqual(currentBg.?, cell.bg, colorEpsilon);
                const sameAttributes = fgMatch and bgMatch and @as(i16, cell.attributes) == currentAttributes;

                if (!sameAttributes or runStart == -1) {
                    if (runLength > 0) {
                        writer.writeAll(ansi.ANSI.reset) catch {};
                    }

                    runStart = @intCast(x);
                    runLength = 0;

                    currentFg = cell.fg;
                    currentBg = cell.bg;
                    currentAttributes = @intCast(cell.attributes);

                    ansi.ANSI.moveToOutput(writer, x + 1, y + 1 + self.renderOffset) catch {};

                    const fgR = rgbaComponentToU8(cell.fg[0]);
                    const fgG = rgbaComponentToU8(cell.fg[1]);
                    const fgB = rgbaComponentToU8(cell.fg[2]);

                    const bgR = rgbaComponentToU8(cell.bg[0]);
                    const bgG = rgbaComponentToU8(cell.bg[1]);
                    const bgB = rgbaComponentToU8(cell.bg[2]);
                    const bgA = cell.bg[3];

                    ansi.ANSI.fgColorOutput(writer, fgR, fgG, fgB) catch {};

                    // If alpha is 0 (transparent), use terminal default background instead of black
                    if (bgA < 0.001) {
                        writer.writeAll("\x1b[49m") catch {};
                    } else {
                        ansi.ANSI.bgColorOutput(writer, bgR, bgG, bgB) catch {};
                    }

                    ansi.TextAttributes.applyAttributesOutputWriter(writer, cell.attributes) catch {};
                }

                // Handle grapheme characters
                if (gp.isGraphemeChar(cell.char)) {
                    const gid: u32 = gp.graphemeIdFromChar(cell.char);
                    const bytes = self.pool.get(gid) catch |err| {
                        self.performShutdownSequence();
                        std.debug.panic("Fatal: no grapheme bytes in pool for gid {d}: {}", .{ gid, err });
                    };
                    if (bytes.len > 0) {
                        const capabilities = self.terminal.getCapabilities();
                        if (capabilities.explicit_width) {
                            const graphemeWidth = gp.charRightExtent(cell.char) + 1;
                            ansi.ANSI.explicitWidthOutput(writer, graphemeWidth, bytes) catch {};
                        } else {
                            writer.writeAll(bytes) catch {};
                        }
                    }
                } else if (gp.isContinuationChar(cell.char)) {
                    // Write a space for continuation cells to clear any previous content
                    writer.writeByte(' ') catch {};
                } else {
                    const len = std.unicode.utf8Encode(@intCast(cell.char), &utf8Buf) catch 1;
                    writer.writeAll(utf8Buf[0..len]) catch {};
                }
                runLength += 1;

                // Update the current buffer with the new cell
                self.currentRenderBuffer.setRaw(x, y, nextCell.?);

                // If this is a grapheme start, also update all continuation cells
                if (gp.isGraphemeChar(nextCell.?.char)) {
                    const rightExtent = gp.charRightExtent(nextCell.?.char);
                    var k: u32 = 1;
                    while (k <= rightExtent and x + k < self.width) : (k += 1) {
                        if (self.nextRenderBuffer.get(x + k, y)) |contCell| {
                            self.currentRenderBuffer.setRaw(x + k, y, contCell);
                        }
                    }
                }

                cellsUpdated += 1;
            }
        }

        writer.writeAll(ansi.ANSI.reset) catch {};

        const cursorPos = self.terminal.getCursorPosition();
        const cursorStyle = self.terminal.getCursorStyle();
        const cursorColor = self.terminal.getCursorColor();

        if (cursorPos.visible) {
            var cursorStyleCode: []const u8 = undefined;

            switch (cursorStyle.style) {
                .block => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorBlockBlink
                    else
                        ansi.ANSI.cursorBlock;
                },
                .line => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorLineBlink
                    else
                        ansi.ANSI.cursorLine;
                },
                .underline => {
                    cursorStyleCode = if (cursorStyle.blinking)
                        ansi.ANSI.cursorUnderlineBlink
                    else
                        ansi.ANSI.cursorUnderline;
                },
            }

            const cursorR = rgbaComponentToU8(cursorColor[0]);
            const cursorG = rgbaComponentToU8(cursorColor[1]);
            const cursorB = rgbaComponentToU8(cursorColor[2]);

            const styleTag: u8 = @intFromEnum(cursorStyle.style);
            const styleChanged = (self.lastCursorStyleTag == null or self.lastCursorStyleTag.? != styleTag) or
                (self.lastCursorBlinking == null or self.lastCursorBlinking.? != cursorStyle.blinking);
            const colorChanged = (self.lastCursorColorRGB == null or self.lastCursorColorRGB.?[0] != cursorR or self.lastCursorColorRGB.?[1] != cursorG or self.lastCursorColorRGB.?[2] != cursorB);

            if (colorChanged) {
                ansi.ANSI.cursorColorOutputWriter(writer, cursorR, cursorG, cursorB) catch {};
                self.lastCursorColorRGB = .{ cursorR, cursorG, cursorB };
            }
            if (styleChanged) {
                writer.writeAll(cursorStyleCode) catch {};
                self.lastCursorStyleTag = styleTag;
                self.lastCursorBlinking = cursorStyle.blinking;
            }
            ansi.ANSI.moveToOutput(writer, cursorPos.x, cursorPos.y + self.renderOffset) catch {};
            writer.writeAll(ansi.ANSI.showCursor) catch {};
        } else {
            writer.writeAll(ansi.ANSI.hideCursor) catch {};
            self.lastCursorStyleTag = null;
            self.lastCursorBlinking = null;
            self.lastCursorColorRGB = null;
        }

        writer.writeAll(ansi.ANSI.syncReset) catch {};

        // Update the output buffer length after all writes
        updateOutputBufferLen(&stream);

        const renderEndTime = std.time.microTimestamp();
        const renderTime = @as(f64, @floatFromInt(renderEndTime - renderStartTime));

        self.renderStats.cellsUpdated = cellsUpdated;
        self.renderStats.renderTime = renderTime;

        self.nextRenderBuffer.clear(.{ self.backgroundColor[0], self.backgroundColor[1], self.backgroundColor[2], self.backgroundColor[3] }, null) catch {};

        const temp = self.currentHitGrid;
        self.currentHitGrid = self.nextHitGrid;
        self.nextHitGrid = temp;
        @memset(self.nextHitGrid, 0);
    }

    pub fn setDebugOverlay(self: *CliRenderer, enabled: bool, corner: DebugOverlayCorner) void {
        self.debugOverlay.enabled = enabled;
        self.debugOverlay.corner = corner;
    }

    pub fn clearTerminal(self: *CliRenderer) void {
        self.stdoutWriter.interface.writeAll(ansi.ANSI.clearAndHome) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn addToHitGrid(self: *CliRenderer, x: i32, y: i32, width: u32, height: u32, id: u32) void {
        const startX = @max(0, x);
        const startY = @max(0, y);
        const endX = @min(@as(i32, @intCast(self.hitGridWidth)), x + @as(i32, @intCast(width)));
        const endY = @min(@as(i32, @intCast(self.hitGridHeight)), y + @as(i32, @intCast(height)));

        if (startX >= endX or startY >= endY) return;

        const uStartX: u32 = @intCast(startX);
        const uStartY: u32 = @intCast(startY);
        const uEndX: u32 = @intCast(endX);
        const uEndY: u32 = @intCast(endY);

        for (uStartY..uEndY) |row| {
            const rowStart = row * self.hitGridWidth;
            const startIdx = rowStart + uStartX;
            const endIdx = rowStart + uEndX;

            @memset(self.nextHitGrid[startIdx..endIdx], id);
        }
    }

    pub fn checkHit(self: *CliRenderer, x: u32, y: u32) u32 {
        if (x >= self.hitGridWidth or y >= self.hitGridHeight) {
            return 0;
        }

        const index = y * self.hitGridWidth + x;
        return self.currentHitGrid[index];
    }

    pub fn dumpHitGrid(self: *CliRenderer) void {
        const timestamp = std.time.timestamp();
        var filename_buf: [64]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "hitgrid_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var buffer: [4096]u8 = undefined;
        var writer = file.writer(&buffer);

        for (0..self.hitGridHeight) |y| {
            for (0..self.hitGridWidth) |x| {
                const index = y * self.hitGridWidth + x;
                const id = self.currentHitGrid[index];

                const char = if (id == 0) '.' else ('0' + @as(u8, @intCast(id % 10)));
                writer.interface.writeByte(char) catch return;
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    fn dumpSingleBuffer(self: *CliRenderer, buffer: *OptimizedBuffer, buffer_name: []const u8, timestamp: i64) void {
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/{s}_buffer_{d}.txt", .{ buffer_name, timestamp }) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        var writer = file.writer(&write_buffer);

        writer.interface.print("{s} Buffer ({d}x{d}):\n", .{ buffer_name, self.width, self.height }) catch return;
        writer.interface.writeAll("Characters:\n") catch return;

        for (0..self.height) |y| {
            for (0..self.width) |x| {
                const cell = buffer.get(@intCast(x), @intCast(y));
                if (cell) |c| {
                    if (gp.isContinuationChar(c.char)) {
                        // skip
                    } else if (gp.isGraphemeChar(c.char)) {
                        const gid: u32 = gp.graphemeIdFromChar(c.char);
                        const bytes = self.pool.get(gid) catch &[_]u8{};
                        if (bytes.len > 0) writer.interface.writeAll(bytes) catch return;
                    } else {
                        var utf8Buf: [4]u8 = undefined;
                        const len = std.unicode.utf8Encode(@intCast(c.char), &utf8Buf) catch 1;
                        writer.interface.writeAll(utf8Buf[0..len]) catch return;
                    }
                } else {
                    writer.interface.writeByte(' ') catch return;
                }
            }
            writer.interface.writeByte('\n') catch return;
        }
        writer.interface.flush() catch return;
    }

    pub fn dumpStdoutBuffer(self: *CliRenderer, timestamp: i64) void {
        _ = self;
        std.fs.cwd().makeDir("buffer_dump") catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return,
        };

        var filename_buf: [128]u8 = undefined;
        const filename = std.fmt.bufPrint(&filename_buf, "buffer_dump/stdout_buffer_{d}.txt", .{timestamp}) catch return;

        const file = std.fs.cwd().createFile(filename, .{}) catch return;
        defer file.close();

        var write_buffer: [4096]u8 = undefined;
        var writer = file.writer(&write_buffer);

        writer.interface.print("Stdout Buffer Output (timestamp: {d}):\n", .{timestamp}) catch return;
        writer.interface.writeAll("Last Rendered ANSI Output:\n") catch return;
        writer.interface.writeAll("================\n") catch return;

        const lastBuffer = if (activeBuffer == .A) &outputBufferB else &outputBuffer;
        const lastLen = if (activeBuffer == .A) outputBufferBLen else outputBufferLen;

        if (lastLen > 0) {
            writer.interface.writeAll(lastBuffer.*[0..lastLen]) catch return;
        } else {
            writer.interface.writeAll("(no output rendered yet)\n") catch return;
        }
        writer.interface.flush() catch return;

        writer.interface.writeAll("\n================\n") catch return;
        writer.interface.print("Buffer size: {d} bytes\n", .{lastLen}) catch return;
        writer.interface.print("Active buffer: {s}\n", .{if (activeBuffer == .A) "A" else "B"}) catch return;
        writer.interface.flush() catch return;
    }

    pub fn dumpBuffers(self: *CliRenderer, timestamp: i64) void {
        self.dumpSingleBuffer(self.currentRenderBuffer, "current", timestamp);
        self.dumpSingleBuffer(self.nextRenderBuffer, "next", timestamp);
        self.dumpStdoutBuffer(timestamp);
    }

    pub fn enableMouse(self: *CliRenderer, enableMovement: bool) void {
        _ = enableMovement; // TODO: Use this to control motion tracking levels
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, true) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn queryPixelResolution(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        writer.writeAll(ansi.ANSI.queryPixelSize) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableMouse(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setMouseMode(writer, false) catch {};

        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn enableKittyKeyboard(self: *CliRenderer, flags: u8) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, true, flags) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn disableKittyKeyboard(self: *CliRenderer) void {
        const writer = &self.stdoutWriter.interface;

        self.terminal.setKittyKeyboard(writer, false, 0) catch {};
        self.stdoutWriter.interface.flush() catch {};
    }

    pub fn getTerminalCapabilities(self: *CliRenderer) Terminal.Capabilities {
        return self.terminal.getCapabilities();
    }

    pub fn processCapabilityResponse(self: *CliRenderer, response: []const u8) void {
        self.terminal.processCapabilityResponse(response);
        const writer = &self.stdoutWriter.interface;
        self.terminal.enableDetectedFeatures(writer, self.useKittyKeyboard) catch {};
    }

    pub fn setCursorPosition(self: *CliRenderer, x: u32, y: u32, visible: bool) void {
        self.terminal.setCursorPosition(x, y, visible);
    }

    pub fn setCursorStyle(self: *CliRenderer, style: Terminal.CursorStyle, blinking: bool) void {
        self.terminal.setCursorStyle(style, blinking);
    }

    pub fn setCursorColor(self: *CliRenderer, color: [4]f32) void {
        self.terminal.setCursorColor(color);
    }

    pub fn setUseKittyKeyboard(self: *CliRenderer, use: bool) void {
        self.useKittyKeyboard = use;
    }

    pub fn getUseKittyKeyboard(self: *CliRenderer) bool {
        return self.useKittyKeyboard;
    }

    fn renderDebugOverlay(self: *CliRenderer) void {
        if (!self.debugOverlay.enabled) return;

        const width: u32 = 40;
        const height: u32 = 11;
        var x: u32 = 0;
        var y: u32 = 0;

        if (self.width < width + 2 or self.height < height + 2) return;

        switch (self.debugOverlay.corner) {
            .topLeft => {
                x = 1;
                y = 1;
            },
            .topRight => {
                x = self.width - width - 1;
                y = 1;
            },
            .bottomLeft => {
                x = 1;
                y = self.height - height - 1;
            },
            .bottomRight => {
                x = self.width - width - 1;
                y = self.height - height - 1;
            },
        }

        self.nextRenderBuffer.fillRect(x, y, width, height, .{ 20.0 / 255.0, 20.0 / 255.0, 40.0 / 255.0, 1.0 }) catch {};
        self.nextRenderBuffer.drawText("Debug Information", x + 1, y + 1, .{ 1.0, 1.0, 100.0 / 255.0, 1.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, ansi.TextAttributes.BOLD) catch {};

        var row: u32 = 2;
        const bg: RGBA = .{ 0.0, 0.0, 0.0, 0.0 };
        const fg: RGBA = .{ 200.0 / 255.0, 200.0 / 255.0, 200.0 / 255.0, 1.0 };

        // Calculate averages
        const lastFrameTimeAvg = getStatAverage(f64, &self.statSamples.lastFrameTime);
        const renderTimeAvg = getStatAverage(f64, &self.statSamples.renderTime);
        const overallFrameTimeAvg = getStatAverage(f64, &self.statSamples.overallFrameTime);
        const bufferResetTimeAvg = getStatAverage(f64, &self.statSamples.bufferResetTime);
        const stdoutWriteTimeAvg = getStatAverage(f64, &self.statSamples.stdoutWriteTime);
        const cellsUpdatedAvg = getStatAverage(u32, &self.statSamples.cellsUpdated);
        const frameCallbackTimeAvg = getStatAverage(f64, &self.statSamples.frameCallbackTime);

        // FPS
        var fpsText: [32]u8 = undefined;
        const fpsLen = std.fmt.bufPrint(&fpsText, "FPS: {d}", .{self.renderStats.fps}) catch return;
        self.nextRenderBuffer.drawText(fpsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Time
        var frameTimeText: [64]u8 = undefined;
        const frameTimeLen = std.fmt.bufPrint(&frameTimeText, "Frame: {d:.3}ms (avg: {d:.3}ms)", .{ self.renderStats.lastFrameTime / 1000.0, lastFrameTimeAvg / 1000.0 }) catch return;
        self.nextRenderBuffer.drawText(frameTimeLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        // Frame Callback Time
        if (self.renderStats.frameCallbackTime) |frameCallbackTime| {
            var frameCallbackTimeText: [64]u8 = undefined;
            const frameCallbackTimeLen = std.fmt.bufPrint(&frameCallbackTimeText, "Frame Callback: {d:.3}ms (avg: {d:.3}ms)", .{ frameCallbackTime, frameCallbackTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(frameCallbackTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Overall Time
        if (self.renderStats.overallFrameTime) |overallTime| {
            var overallTimeText: [64]u8 = undefined;
            const overallTimeLen = std.fmt.bufPrint(&overallTimeText, "Overall: {d:.3}ms (avg: {d:.3}ms)", .{ overallTime, overallFrameTimeAvg }) catch return;
            self.nextRenderBuffer.drawText(overallTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Render Time
        if (self.renderStats.renderTime) |renderTime| {
            var renderTimeText: [64]u8 = undefined;
            const renderTimeLen = std.fmt.bufPrint(&renderTimeText, "Render: {d:.3}ms (avg: {d:.3}ms)", .{ renderTime / 1000.0, renderTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(renderTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Buffer Reset Time
        if (self.renderStats.bufferResetTime) |resetTime| {
            var resetTimeText: [64]u8 = undefined;
            const resetTimeLen = std.fmt.bufPrint(&resetTimeText, "Reset: {d:.3}ms (avg: {d:.3}ms)", .{ resetTime / 1000.0, bufferResetTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(resetTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Stdout Write Time
        if (self.renderStats.stdoutWriteTime) |writeTime| {
            var writeTimeText: [64]u8 = undefined;
            const writeTimeLen = std.fmt.bufPrint(&writeTimeText, "Stdout: {d:.3}ms (avg: {d:.3}ms)", .{ writeTime / 1000.0, stdoutWriteTimeAvg / 1000.0 }) catch return;
            self.nextRenderBuffer.drawText(writeTimeLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Cells Updated
        var cellsText: [64]u8 = undefined;
        const cellsLen = std.fmt.bufPrint(&cellsText, "Cells: {d} (avg: {d})", .{ self.renderStats.cellsUpdated, cellsUpdatedAvg }) catch return;
        self.nextRenderBuffer.drawText(cellsLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;

        if (self.renderStats.heapUsed > 0 or self.renderStats.heapTotal > 0) {
            var memoryText: [64]u8 = undefined;
            const memoryLen = std.fmt.bufPrint(&memoryText, "Memory: {d:.2}MB / {d:.2}MB / {d:.2}MB", .{ @as(f64, @floatFromInt(self.renderStats.heapUsed)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.heapTotal)) / 1024.0 / 1024.0, @as(f64, @floatFromInt(self.renderStats.arrayBuffers)) / 1024.0 / 1024.0 }) catch return;
            self.nextRenderBuffer.drawText(memoryLen, x + 1, y + row, fg, bg, 0) catch {};
            row += 1;
        }

        // Is threaded?
        var isThreadedText: [64]u8 = undefined;
        const isThreadedLen = std.fmt.bufPrint(&isThreadedText, "Threaded: {s}", .{if (self.useThread) "Yes" else "No"}) catch return;
        self.nextRenderBuffer.drawText(isThreadedLen, x + 1, y + row, fg, bg, 0) catch {};
        row += 1;
    }
};

```


## Assistant

Now let me try compiling again:

**Tool Call: Compile and check for remaining errors**
Status: Completed

Terminal:
```





```


## Assistant

Excellent! The build succeeded! Let me update the todo list and commit the changes:Now let me commit the changes:

**Tool Call: Commit ansi.zig and renderer.zig changes**
Status: Completed

Terminal:
```
  â–¶ Check credentials by secretlint
[main b9a70e8] zig: complete Phase 2 & 3 - migrate ansi.zig and renderer.zig to 0.15.1
 2 files changed, 60 insertions(+), 54 deletions(-)


```


## Assistant

Perfect! Now let me update MIGRATION_STATUS.md:

**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md (2 - 101)**
Status: Completed

```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [~] Phase 2: Core Data Structures (7/8 files - Writer API migration in progress)
- [ ] Phase 3: I/O & Formatting (0/2 files)
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 9/38 items complete (24%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | ðŸŸ¡ In Progress | 7 (statSamples) | 0 | 0 | BufferedWriter + Writer API | Session 4 - 60% complete, ~80 lines changed |
| lib.zig | ðŸŸ¡ In Progress | 0 | 0 | 0 | Writer API update | Session 4 - setTerminalTitle fixed |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | ðŸŸ¡ Blocked | 0 | 0 | 6 | Writer API changes | Needs fmt.format â†’ print, writeByteNTimes removal |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
```

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)
```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | ðŸŸ¡ Blocked | 0 | 0 | 6 | Writer API changes | Needs fmt.format â†’ print, writeByteNTimes removal |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Remaining Compilation Errors** (8-9 total):

From renderer.zig:
- `OutputBufferWriter` custom writer needs migration to concrete Writer type
- `addStatSample()` function needs allocator parameter
- Multiple call sites need to pass allocator to `addStatSample()`

From ansi.zig:
- `std.fmt.format()` â†’ `writer.print()` (6 occurrences)
- `writer.writeByteNTimes()` removed from API (need manual loop)

**Migration patterns documented**:
- Pattern 12: BufferedWriter â†’ File.Writer with Buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 8 (21%)
- **Files in progress**: 2 (renderer.zig, lib.zig)
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 0/17 (Phase 3 - ansi.zig blocked)
- **Writer API migrations**: ~30 call sites (renderer.zig)
- **Lines changed**: ~230 total (150 in Session 3, 80 in Session 4)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)
- Option 2: Check if still needed, possibly simplify
- Location: renderer.zig:118-136, used at line 549

### 2. Complete ansi.zig Migration (~20-30 min)

**Task A**: Replace `std.fmt.format()` calls (6 occurrences)
```zig
// Before
try std.fmt.format(writer, "text {d}", .{x});

// After  
try writer.print("text {d}", .{x});
```

**Task B**: Replace `writeByteNTimes()` (1 occurrence at line 139)
```zig
// Before
writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;

// After
for (0..height - 1) |_| {
    writer.writeByte('\n') catch return AnsiError.WriteFailed;
}
```

### 3. First Compilation Test (~5 min)

```bash
export PATH="$HOME/.zvm/bin:$PATH"
cd packages/core/src/zig
zig build
```

**Expected outcome**: Library should compile (but tests will fail)

### 4. Begin Test Migration Strategy

**Option A** (Recommended): Batch process ArrayList changes
- Create search/replace script for common patterns
- Apply to all test files at once
- Fix individual issues afterward

**Option B**: Incremental migration
- Pick 2-3 test files
- Migrate fully
- Run tests to validate approach

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. ðŸŸ¡ renderer.zig complete (90% done)
3. ðŸŸ¡ ansi.zig complete (not started)
4. â¬œ All test files migrated (24 files)
5. â¬œ All benchmark files migrated (10 files)

**Estimated remaining work**: 6-10 hours across multiple sessions

```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | âœ… Done | 0 | 0 | 6 | writer.print() + writeByteNTimes loop | Session 5 - 6 fmt.format â†’ print, writeByteNTimes â†’ for loop |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Remaining Compilation Errors** (8-9 total):

From renderer.zig:
- `OutputBufferWriter` custom writer needs migration to concrete Writer type
- `addStatSample()` function needs allocator parameter
- Multiple call sites need to pass allocator to `addStatSample()`

From ansi.zig:
- `std.fmt.format()` â†’ `writer.print()` (6 occurrences)
- `writer.writeByteNTimes()` removed from API (need manual loop)

**Migration patterns documented**:
- Pattern 12: BufferedWriter â†’ File.Writer with Buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 8 (21%)
- **Files in progress**: 2 (renderer.zig, lib.zig)
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 0/17 (Phase 3 - ansi.zig blocked)
- **Writer API migrations**: ~30 call sites (renderer.zig)
- **Lines changed**: ~230 total (150 in Session 3, 80 in Session 4)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)
- Option 2: Check if still needed, possibly simplify
- Location: renderer.zig:118-136, used at line 549

### 2. Complete ansi.zig Migration (~20-30 min)

**Task A**: Replace `std.fmt.format()` calls (6 occurrences)
```zig
// Before
try std.fmt.format(writer, "text {d}", .{x});

// After  
try writer.print("text {d}", .{x});
```

**Task B**: Replace `writeByteNTimes()` (1 occurrence at line 139)
```zig
// Before
writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;

// After
for (0..height - 1) |_| {
    writer.writeByte('\n') catch return AnsiError.WriteFailed;
}
```

### 3. First Compilation Test (~5 min)

```bash
export PATH="$HOME/.zvm/bin:$PATH"
cd packages/core/src/zig
zig build
```

**Expected outcome**: Library should compile (but tests will fail)

### 4. Begin Test Migration Strategy

**Option A** (Recommended): Batch process ArrayList changes
- Create search/replace script for common patterns
- Apply to all test files at once
- Fix individual issues afterward

**Option B**: Incremental migration
- Pick 2-3 test files
- Migrate fully
- Run tests to validate approach

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. ðŸŸ¡ renderer.zig complete (90% done)
3. ðŸŸ¡ ansi.zig complete (not started)
4. â¬œ All test files migrated (24 files)
5. â¬œ All benchmark files migrated (10 files)

**Estimated remaining work**: 6-10 hours across multiple sessions

```


## Assistant

Now let me update the Key Statistics and Blockers sections:

**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md (121 - 200)**
Status: Completed

````
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Remaining Compilation Errors** (8-9 total):

From renderer.zig:
- `OutputBufferWriter` custom writer needs migration to concrete Writer type
- `addStatSample()` function needs allocator parameter
- Multiple call sites need to pass allocator to `addStatSample()`

From ansi.zig:
- `std.fmt.format()` â†’ `writer.print()` (6 occurrences)
- `writer.writeByteNTimes()` removed from API (need manual loop)

**Migration patterns documented**:
- Pattern 12: BufferedWriter â†’ File.Writer with Buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 8 (21%)
- **Files in progress**: 2 (renderer.zig, lib.zig)
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 0/17 (Phase 3 - ansi.zig blocked)
- **Writer API migrations**: ~30 call sites (renderer.zig)
- **Lines changed**: ~230 total (150 in Session 3, 80 in Session 4)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)


<file-read-info>Read lines 120-81. </file-read-info>
````

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | âœ… Done | 0 | 0 | 6 | writer.print() + writeByteNTimes loop | Session 5 - 6 fmt.format â†’ print, writeByteNTimes â†’ for loop |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Session 5 (2025-11-20)** - RESOLVED âœ…

All Phase 2 and Phase 3 core files now compile successfully!

**Completed migrations**:
- âœ… ansi.zig: All 6 `std.fmt.format()` â†’ `writer.print()`
- âœ… ansi.zig: `writeByteNTimes()` â†’ manual for loop
- âœ… renderer.zig: `addStatSample()` now takes allocator parameter (7 call sites updated)
- âœ… renderer.zig: `OutputBufferWriter` replaced with `std.io.FixedBufferStream`
- âœ… renderer.zig: All `file.writer()` calls updated with buffer parameter + var writer
- âœ… **Build passes**: `zig build` completes with 0 errors!

**Migration patterns applied**:
- Pattern 12: BufferedWriter â†’ FixedBufferStream with buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading
- **New Pattern 15**: FixedBufferStream for custom output buffers

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 8 (21%)
- **Files in progress**: 2 (renderer.zig, lib.zig)
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 0/17 (Phase 3 - ansi.zig blocked)
- **Writer API migrations**: ~30 call sites (renderer.zig)
- **Lines changed**: ~230 total (150 in Session 3, 80 in Session 4)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)
- Option 2: Check if still needed, possibly simplify
- Location: renderer.zig:118-136, used at line 549

### 2. Complete ansi.zig Migration (~20-30 min)

**Task A**: Replace `std.fmt.format()` calls (6 occurrences)
```zig
// Before
try std.fmt.format(writer, "text {d}", .{x});

// After  
try writer.print("text {d}", .{x});
```

**Task B**: Replace `writeByteNTimes()` (1 occurrence at line 139)
```zig
// Before
writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;

// After
for (0..height - 1) |_| {
    writer.writeByte('\n') catch return AnsiError.WriteFailed;
}
```

### 3. First Compilation Test (~5 min)

```bash
export PATH="$HOME/.zvm/bin:$PATH"
cd packages/core/src/zig
zig build
```

**Expected outcome**: Library should compile (but tests will fail)

### 4. Begin Test Migration Strategy

**Option A** (Recommended): Batch process ArrayList changes
- Create search/replace script for common patterns
- Apply to all test files at once
- Fix individual issues afterward

**Option B**: Incremental migration
- Pick 2-3 test files
- Migrate fully
- Run tests to validate approach

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. ðŸŸ¡ renderer.zig complete (90% done)
3. ðŸŸ¡ ansi.zig complete (not started)
4. â¬œ All test files migrated (24 files)
5. â¬œ All benchmark files migrated (10 files)

**Estimated remaining work**: 6-10 hours across multiple sessions

```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | âœ… Done | 0 | 0 | 6 | writer.print() + writeByteNTimes loop | Session 5 - 6 fmt.format â†’ print, writeByteNTimes â†’ for loop |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Session 5 (2025-11-20)** - RESOLVED âœ…

All Phase 2 and Phase 3 core files now compile successfully!

**Completed migrations**:
- âœ… ansi.zig: All 6 `std.fmt.format()` â†’ `writer.print()`
- âœ… ansi.zig: `writeByteNTimes()` â†’ manual for loop
- âœ… renderer.zig: `addStatSample()` now takes allocator parameter (7 call sites updated)
- âœ… renderer.zig: `OutputBufferWriter` replaced with `std.io.FixedBufferStream`
- âœ… renderer.zig: All `file.writer()` calls updated with buffer parameter + var writer
- âœ… **Build passes**: `zig build` completes with 0 errors!

**Migration patterns applied**:
- Pattern 12: BufferedWriter â†’ FixedBufferStream with buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading
- **New Pattern 15**: FixedBufferStream for custom output buffers

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 11 (29%)
- **Files in progress**: 0
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 6/17 (Phase 3 complete for ansi.zig)
- **Writer API migrations**: ~40 call sites (renderer.zig + ansi.zig)
- **Lines changed**: ~290 total (150 in Session 3, 80 in Session 4, 60 in Session 5)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)
- Option 2: Check if still needed, possibly simplify
- Location: renderer.zig:118-136, used at line 549

### 2. Complete ansi.zig Migration (~20-30 min)

**Task A**: Replace `std.fmt.format()` calls (6 occurrences)
```zig
// Before
try std.fmt.format(writer, "text {d}", .{x});

// After  
try writer.print("text {d}", .{x});
```

**Task B**: Replace `writeByteNTimes()` (1 occurrence at line 139)
```zig
// Before
writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;

// After
for (0..height - 1) |_| {
    writer.writeByte('\n') catch return AnsiError.WriteFailed;
}
```

### 3. First Compilation Test (~5 min)

```bash
export PATH="$HOME/.zvm/bin:$PATH"
cd packages/core/src/zig
zig build
```

**Expected outcome**: Library should compile (but tests will fail)

### 4. Begin Test Migration Strategy

**Option A** (Recommended): Batch process ArrayList changes
- Create search/replace script for common patterns
- Apply to all test files at once
- Fix individual issues afterward

**Option B**: Incremental migration
- Pick 2-3 test files
- Migrate fully
- Run tests to validate approach

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. ðŸŸ¡ renderer.zig complete (90% done)
3. ðŸŸ¡ ansi.zig complete (not started)
4. â¬œ All test files migrated (24 files)
5. â¬œ All benchmark files migrated (10 files)

**Estimated remaining work**: 6-10 hours across multiple sessions

```


## Assistant

Now let me update the "Next Session Action" section:

**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md (176 - 255)**
Status: Completed

````

---

## Next Session Action

**Session 5 Priority Tasks** (Critical Path):

### 1. Complete renderer.zig Migration (~30-60 min)

**Task A**: Fix `addStatSample()` function
```zig
// Add allocator parameter (line ~345)
fn addStatSample(comptime T: type, allocator: Allocator, samples: *std.ArrayList(T), value: T) void {
    samples.append(allocator, value) catch return;
    // ...
}
```

**Task B**: Update all `addStatSample()` call sites (7 locations)
```bash
# Find them:
grep -n "addStatSample" renderer.zig
# Add allocator parameter to each call
```

**Task C**: Migrate or remove `OutputBufferWriter`
- Option 1: Migrate to new Writer API (complex)
- Option 2: Check if still needed, possibly simplify
- Location: renderer.zig:118-136, used at line 549

### 2. Complete ansi.zig Migration (~20-30 min)

**Task A**: Replace `std.fmt.format()` calls (6 occurrences)
```zig
// Before
try std.fmt.format(writer, "text {d}", .{x});

// After  
try writer.print("text {d}", .{x});
```

**Task B**: Replace `writeByteNTimes()` (1 occurrence at line 139)
```zig
// Before
writer.writeByteNTimes('\n', height - 1) catch return AnsiError.WriteFailed;

// After
for (0..height - 1) |_| {
    writer.writeByte('\n') catch return AnsiError.WriteFailed;
}
```

### 3. First Compilation Test (~5 min)

```bash
export PATH="$HOME/.zvm/bin:$PATH"
cd packages/core/src/zig
zig build
```

**Expected outcome**: Library should compile (but tests will fail)

### 4. Begin Test Migration Strategy

**Option A** (Recommended): Batch process ArrayList changes
- Create search/replace script for common patterns
- Apply to all test files at once
- Fix individual issues afterward

**Option B**: Incremental migration
- Pick 2-3 test files
- Migrate fully
- Run tests to validate approach

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)


<file-read-info>Read lines 175-81. </file-read-info>
````

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | âœ… Done | 0 | 0 | 6 | writer.print() + writeByteNTimes loop | Session 5 - 6 fmt.format â†’ print, writeByteNTimes â†’ for loop |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Session 5 (2025-11-20)** - RESOLVED âœ…

All Phase 2 and Phase 3 core files now compile successfully!

**Completed migrations**:
- âœ… ansi.zig: All 6 `std.fmt.format()` â†’ `writer.print()`
- âœ… ansi.zig: `writeByteNTimes()` â†’ manual for loop
- âœ… renderer.zig: `addStatSample()` now takes allocator parameter (7 call sites updated)
- âœ… renderer.zig: `OutputBufferWriter` replaced with `std.io.FixedBufferStream`
- âœ… renderer.zig: All `file.writer()` calls updated with buffer parameter + var writer
- âœ… **Build passes**: `zig build` completes with 0 errors!

**Migration patterns applied**:
- Pattern 12: BufferedWriter â†’ FixedBufferStream with buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading
- **New Pattern 15**: FixedBufferStream for custom output buffers

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 11 (29%)
- **Files in progress**: 0
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 6/17 (Phase 3 complete for ansi.zig)
- **Writer API migrations**: ~40 call sites (renderer.zig + ansi.zig)
- **Lines changed**: ~290 total (150 in Session 3, 80 in Session 4, 60 in Session 5)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 6 Priority Tasks** - Begin Test Migration

### 1. Verify Current State (~5 min)

```bash
cd packages/core/src/zig
export PATH="$HOME/.zvm/bin:$PATH"
zig build          # Should succeed
zig build test     # Will fail - tests not yet migrated
```

### 2. Choose Test Migration Strategy

**Option A** (Recommended): Incremental migration
- Pick 2-3 simple test files (e.g., `grapheme_test.zig`, `utf8_test.zig`)
- Migrate fully
- Run tests to validate approach
- Document any new patterns discovered
- Continue with remaining test files

**Option B**: Batch process ArrayList changes
- Create search/replace patterns for common cases
- Apply to all test files at once
- Fix individual issues afterward
- Risk: May introduce subtle bugs

**Recommended**: Option A (incremental)

### 3. Expected Test File Changes

Based on ArrayList semantic change in 0.15.1, expect:
```zig
// Before (0.14.1)
var list = std.ArrayList(T).init(allocator);
defer list.deinit();

// After (0.15.1) 
var list: std.ArrayList(T) = .{};
defer list.deinit(allocator);
```

All `.append()`, `.appendSlice()`, etc. need allocator parameter.

### 4. First Test Files to Migrate (~1-2 hours)

**Easy wins** (low complexity):
1. `grapheme_test.zig` - Simple grapheme tests
2. `utf8_test.zig` - UTF-8 boundary tests
3. `utils_test.zig` - Utility functions

**Medium complexity**:
4. `rope_test.zig` - Core rope tests
5. `buffer_test.zig` - Buffer tests

Save complex files (text-buffer tests) for later.

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. ðŸŸ¡ renderer.zig complete (90% done)
3. ðŸŸ¡ ansi.zig complete (not started)
4. â¬œ All test files migrated (24 files)
5. â¬œ All benchmark files migrated (10 files)

**Estimated remaining work**: 6-10 hours across multiple sessions

```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 2 - Core Data Structures (90% Complete - API migration in progress)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | âœ… Done | 0 | 0 | 6 | writer.print() + writeByteNTimes loop | Session 5 - 6 fmt.format â†’ print, writeByteNTimes â†’ for loop |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Session 5 (2025-11-20)** - RESOLVED âœ…

All Phase 2 and Phase 3 core files now compile successfully!

**Completed migrations**:
- âœ… ansi.zig: All 6 `std.fmt.format()` â†’ `writer.print()`
- âœ… ansi.zig: `writeByteNTimes()` â†’ manual for loop
- âœ… renderer.zig: `addStatSample()` now takes allocator parameter (7 call sites updated)
- âœ… renderer.zig: `OutputBufferWriter` replaced with `std.io.FixedBufferStream`
- âœ… renderer.zig: All `file.writer()` calls updated with buffer parameter + var writer
- âœ… **Build passes**: `zig build` completes with 0 errors!

**Migration patterns applied**:
- Pattern 12: BufferedWriter â†’ FixedBufferStream with buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading
- **New Pattern 15**: FixedBufferStream for custom output buffers

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 11 (29%)
- **Files in progress**: 0
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 6/17 (Phase 3 complete for ansi.zig)
- **Writer API migrations**: ~40 call sites (renderer.zig + ansi.zig)
- **Lines changed**: ~290 total (150 in Session 3, 80 in Session 4, 60 in Session 5)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 6 Priority Tasks** - Begin Test Migration

### 1. Verify Current State (~5 min)

```bash
cd packages/core/src/zig
export PATH="$HOME/.zvm/bin:$PATH"
zig build          # Should succeed
zig build test     # Will fail - tests not yet migrated
```

### 2. Choose Test Migration Strategy

**Option A** (Recommended): Incremental migration
- Pick 2-3 simple test files (e.g., `grapheme_test.zig`, `utf8_test.zig`)
- Migrate fully
- Run tests to validate approach
- Document any new patterns discovered
- Continue with remaining test files

**Option B**: Batch process ArrayList changes
- Create search/replace patterns for common cases
- Apply to all test files at once
- Fix individual issues afterward
- Risk: May introduce subtle bugs

**Recommended**: Option A (incremental)

### 3. Expected Test File Changes

Based on ArrayList semantic change in 0.15.1, expect:
```zig
// Before (0.14.1)
var list = std.ArrayList(T).init(allocator);
defer list.deinit();

// After (0.15.1) 
var list: std.ArrayList(T) = .{};
defer list.deinit(allocator);
```

All `.append()`, `.appendSlice()`, etc. need allocator parameter.

### 4. First Test Files to Migrate (~1-2 hours)

**Easy wins** (low complexity):
1. `grapheme_test.zig` - Simple grapheme tests
2. `utf8_test.zig` - UTF-8 boundary tests
3. `utils_test.zig` - Utility functions

**Medium complexity**:
4. `rope_test.zig` - Core rope tests
5. `buffer_test.zig` - Buffer tests

Save complex files (text-buffer tests) for later.

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. âœ… renderer.zig complete (done)
3. âœ… ansi.zig complete (done)
4. â¬œ All test files migrated (0/14 files)
5. â¬œ All benchmark files migrated (0/10 files)

**Estimated remaining work**: 5-8 hours across multiple sessions

```


## Assistant

Perfect! Now let me update the current phase at the top:

**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_STATUS.md
```
# Zig 0.14.1 â†’ 0.15.1 Migration Status

**Started**: 2025-11-19  
**Target Completion**: TBD  
**Current Phase**: Phase 4 - Test Files (Ready to begin migration)

---

## Overall Progress

- [x] Phase 1: Preparation & Build System (2/2 files) âœ”ï¸
- [x] Phase 2: Core Data Structures (8/8 files) âœ”ï¸
- [x] Phase 3: I/O & Formatting (1/2 files) âœ”ï¸
- [ ] Phase 4: Test Files (0/14 files)
- [ ] Phase 5: Benchmark Files (0/10 files)
- [ ] Phase 6: Validation (0/4 tasks)

**Total**: 11/38 items complete (29%)

---

## Phase 1: Preparation & Build System

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| build.zig | âœ… Done | N/A | N/A | N/A | Add 0.15.0, 0.15.1 to SUPPORTED_ZIG_VERSIONS | Session 2 - API migrations |
| build.zig.zon | âœ… Done | N/A | N/A | N/A | uucode dependency | Session 2 + Session 4 update to commit 7e7f986 |

---

## Phase 2: Core Data Structures (CRITICAL PATH)

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| rope.zig | âœ… Done | 8 | 1 | 0 (skipped debug) | MarkerCache migration | Session 3 - 64 insertions, 57 deletions |
| utf8.zig | âœ… Done | 4 | 0 | 0 | Result structs + findGraphemeInfoSIMD16 | Session 3 - 35 insertions, 27 deletions |
| buffer.zig | âœ… Done | 2 | 0 | 0 | scissor_stack, grapheme list | Session 3 - 11 insertions, 10 deletions |
| text-buffer.zig | âœ… Done | 2 | 1 | 0 | Return types, event list, active map | Session 3 - 22 insertions, 22 deletions |
| text-buffer-segment.zig | âœ… Done | 1 | 0 | 0 | grapheme processing | Session 3 - included in text-buffer commit |
| edit-buffer.zig | âœ… Done | 0 | 0 | 0 | Caller updates for new signatures | Session 3 - 2 insertions, 2 deletions |
| renderer.zig | âœ… Done | 7 (statSamples) | 0 | 0 | OutputBufferWriter + file.writer() + addStatSample | Session 5 - 60 insertions, 54 deletions |
| lib.zig | âœ… Done | 0 | 0 | 0 | No changes needed after ansi.zig fix | Session 5 - indirect fix via ansi.zig |
| grapheme.zig | âœ… Skip | 0 | 0 | 0 | Already uses correct APIs | No changes needed |

---

## Phase 3: I/O & Formatting

| File | Status | ArrayList | HashMap | fmt.format | Other | Notes |
|------|--------|-----------|---------|------------|-------|-------|
| ansi.zig | âœ… Done | 0 | 0 | 6 | writer.print() + writeByteNTimes loop | Session 5 - 6 fmt.format â†’ print, writeByteNTimes â†’ for loop |
| rope.zig debug | â¬œ Not Started | N/A | N/A | 4 | Debug output only | Low priority |

---

## Phase 4: Test Files

âš ï¸ **CRITICAL UPDATE**: All test files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | fmt.format | Notes |
|------|--------|-----------|------------|-------|
| buffer_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| edit-buffer_test.zig | â¬œ Not Started | Multiple | 0 | Already uses Unmanaged, still needs 0.15.1 updates |
| event-bus_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| grapheme_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| rope_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| syntax-style_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer_test.zig | â¬œ Not Started | Multiple | 3 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-drawing_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-view_test.zig | â¬œ Not Started | Multiple | 4 | Needs .init(a) â†’ .{} + fmt.format migration |
| text-buffer-iterators_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| text-buffer-segment_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| terminal_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utf8_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |
| utils_test.zig | â¬œ Not Started | Multiple | 0 | Needs .init(a) â†’ .{} migration |

---

## Phase 5: Benchmark Files

âš ï¸ **CRITICAL UPDATE**: All benchmark files affected by ArrayList default change in 0.15.1!

| File | Status | ArrayList | Notes |
|------|--------|-----------|-------|
| bench-rope-append.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-insert.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-iterate.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-rewrite.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-rope-split.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-apply-edits.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-segment.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-text-buffer-view.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-boundary.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |
| bench-utf8-graphemes.zig | â¬œ Not Started | Multiple | Needs .init(a) â†’ .{} migration |

---

## Phase 6: Validation

- [ ] Full test suite passes on Zig 0.15.1
- [ ] Benchmark suite runs without errors
- [ ] Performance regression check (compare with 0.14.1)
- [ ] Integration test with TypeScript/JS FFI layer

---

## Blockers & Issues

**Session 1-3** - RESOLVED âœ…

**Session 4 (2025-11-19)** - Major API Changes Discovered:

**BREAKING CHANGES DISCOVERED** ðŸš¨:

1. **ArrayList Semantic Change** (affects ALL files):
   - `std.ArrayList` is now `ArrayListUnmanaged` by default in 0.15.1
   - `.init(allocator)` â†’ `: std.ArrayList(T) = .{}`
   - All methods require allocator: `.append(item)` â†’ `.append(allocator, item)`
   - Even `.deinit()` â†’ `.deinit(allocator)`
   - **Impact**: All 24 test + benchmark files affected!

2. **Writer/Reader Redesign** ("Writergate"):
   - `std.io.BufferedWriter` type removed
   - New pattern: explicit buffer + `file.writer(&buffer)` + `&writer.interface`
   - Writers are concrete types now, not generics
   - **Impact**: renderer.zig, ansi.zig, potentially others

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - **Impact**: renderer.zig and any file using these functions

**Session 5 (2025-11-20)** - RESOLVED âœ…

All Phase 2 and Phase 3 core files now compile successfully!

**Completed migrations**:
- âœ… ansi.zig: All 6 `std.fmt.format()` â†’ `writer.print()`
- âœ… ansi.zig: `writeByteNTimes()` â†’ manual for loop
- âœ… renderer.zig: `addStatSample()` now takes allocator parameter (7 call sites updated)
- âœ… renderer.zig: `OutputBufferWriter` replaced with `std.io.FixedBufferStream`
- âœ… renderer.zig: All `file.writer()` calls updated with buffer parameter + var writer
- âœ… **Build passes**: `zig build` completes with 0 errors!

**Migration patterns applied**:
- Pattern 12: BufferedWriter â†’ FixedBufferStream with buffer
- Pattern 13: ArrayList Default Semantic Change
- Pattern 14: Function Parameters with Allocator Threading
- **New Pattern 15**: FixedBufferStream for custom output buffers

---

## Key Statistics

- **Total Files**: 38
- **Files fully migrated**: 11 (29%)
- **Files in progress**: 0
- **ArrayList migrations completed**: 25/~163
- **HashMap migrations completed**: 2/5
- **fmt.format updates**: 6/17 (Phase 3 complete for ansi.zig)
- **Writer API migrations**: ~40 call sites (renderer.zig + ansi.zig)
- **Lines changed**: ~290 total (150 in Session 3, 80 in Session 4, 60 in Session 5)

---

## Status Legend

- â¬œ Not Started
- ðŸŸ¡ In Progress
- ðŸ”´ Blocked (dependency issue)
- âœ… Done (code updated)
- âœ”ï¸ Tested (tests passing)
- âš ï¸ Blocked
- âŒ Failed (needs attention)

---

## Next Session Action

**Session 6 Priority Tasks** - Begin Test Migration

### 1. Verify Current State (~5 min)

```bash
cd packages/core/src/zig
export PATH="$HOME/.zvm/bin:$PATH"
zig build          # Should succeed
zig build test     # Will fail - tests not yet migrated
```

### 2. Choose Test Migration Strategy

**Option A** (Recommended): Incremental migration
- Pick 2-3 simple test files (e.g., `grapheme_test.zig`, `utf8_test.zig`)
- Migrate fully
- Run tests to validate approach
- Document any new patterns discovered
- Continue with remaining test files

**Option B**: Batch process ArrayList changes
- Create search/replace patterns for common cases
- Apply to all test files at once
- Fix individual issues afterward
- Risk: May introduce subtle bugs

**Recommended**: Option A (incremental)

### 3. Expected Test File Changes

Based on ArrayList semantic change in 0.15.1, expect:
```zig
// Before (0.14.1)
var list = std.ArrayList(T).init(allocator);
defer list.deinit();

// After (0.15.1) 
var list: std.ArrayList(T) = .{};
defer list.deinit(allocator);
```

All `.append()`, `.appendSlice()`, etc. need allocator parameter.

### 4. First Test Files to Migrate (~1-2 hours)

**Easy wins** (low complexity):
1. `grapheme_test.zig` - Simple grapheme tests
2. `utf8_test.zig` - UTF-8 boundary tests
3. `utils_test.zig` - Utility functions

**Medium complexity**:
4. `rope_test.zig` - Core rope tests
5. `buffer_test.zig` - Buffer tests

Save complex files (text-buffer tests) for later.

---

## Critical Dependencies

Before tests can pass:
1. âœ… Core files migrated (done)
2. âœ… renderer.zig complete (done)
3. âœ… ansi.zig complete (done)
4. â¬œ All test files migrated (0/14 files)
5. â¬œ All benchmark files migrated (0/10 files)

**Estimated remaining work**: 5-8 hours across multiple sessions

```


## Assistant

Now let me commit the MIGRATION_STATUS.md changes and then update MIGRATION_LOG.md:

**Tool Call: Commit MIGRATION_STATUS.md updates**
Status: Completed

Terminal:
```
  â–¶ Check credentials by secretlint
[main 32e4cde] zig: update migration status - Phase 2 & 3 complete (Session 5)
 1 file changed, 75 insertions(+), 86 deletions(-)


```


## Assistant

Now let me update MIGRATION_LOG.md:

**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_LOG.md (2 - 81)**
Status: Completed

```
# Zig 0.15.1 Migration Log

Chronological record of all changes made during the migration.

---

## Session 1: 2025-11-19

### Setup & Planning
- Created migration tracking system
- Created MIGRATION_STATUS.md - overall progress tracker
- Created MIGRATION_LOG.md - this file
- Created MIGRATION_PATTERNS.md - pattern reference guide
- Created .migration/ directory with phase checklists

### Files Created
- `MIGRATION_STATUS.md`
- `MIGRATION_LOG.md`
- `MIGRATION_PATTERNS.md`
- `.migration/phase-1-prep.md`
- `.migration/phase-2-core.md`
- `.migration/phase-3-io.md`
- `.migration/phase-4-tests.md`
- `.migration/phase-5-bench.md`
- `.migration/phase-6-validation.md`

### Next Steps
- ~~Start Phase 1: Update build.zig~~ COMPLETED
- ~~Check uucode dependency compatibility~~ COMPLETED

---

## Session 2: 2025-11-19 (First Migration Session)

### Work Completed

**Phase 1: Build System Updates** âœ…

- **File**: build.zig
  - Changes: Added Zig 0.15.0 and 0.15.1 to SUPPORTED_ZIG_VERSIONS array
  - Changes: Fixed API changes for Zig 0.15.1:
    - `addTest`: Changed `.root_source_file` to `.root_module = b.createModule()`
    - `addExecutable`: Same root_module pattern for bench and debug executables
    - Removed `.filter` from TestOptions (not supported in 0.15.1)
  - Test result: Build system compiles successfully

- **File**: build.zig.zon
  - Changes: Updated uucode dependency to Zig 0.15.1 compatible version
    - Old: `https://github.com/jacobsandlund/uucode/archive/refs/tags/v0.1.0-zig-0.14.tar.gz`
    - New: `git+https://github.com/jacobsandlund/uucode#5f05f8f83a75caea201f12cc8ea32a2d82ea9732`
    - Updated hash to: `uucode-0.1.0-ZZjBPj96QADXyt5sqwBJUnhaDYs_qBeeKijZvlRa0eqM`
  - Resolution: Found compatible version from libvaxis project
  - Test result: Dependency fetches and compiles successfully

### Issues Encountered

1. **Issue**: Zig version manager (zvm) not updating PATH
   - Symptom: `zvm use 0.15.1` succeeded but `zig version` still showed 0.14.1
   - Root cause: Homebrew zig@0.14 installation in PATH taking precedence
   - Resolution: Manually set PATH with `export PATH="$HOME/.zvm/bin:$PATH"` in shell session
   - Note: User may need to restart terminal or update shell config for persistence

2. **Issue**: uucode dependency only had Zig 0.14 tagged release
   - Resolution: Found unreleased commit (5f05f8f) compatible with 0.15.1 via libvaxis project
   - Used git URL with commit hash instead of tagged release

3. **Issue**: Build API changes in Zig 0.15.1
   - `.root_source_file` field removed from addTest/addExecutable
   - `.filter` field removed from TestOptions  
   - Resolution: Used `b.createModule()` pattern and moved filter handling to environment variable

### Test Results

**Build System**: âœ… PASS
- `zig build` executes without build.zig errors
- uucode dependency fetched and compiled successfully

**Source Code Compilation**: âš ï¸ EXPECTED FAILURES (19 errors across all targets)
- ArrayList.init() calls need migration to ArrayListUnmanaged
- callconv(.C) needs to change to callconv(.c)
```

## Assistant

Let me read more to find where to add the new session:

**Tool Call: Find session headers**
Status: Completed

Terminal:
```
7:## Session 1: 2025-11-19
33:## Session 2: 2025-11-19 (First Migration Session)
129:## Session Template (copy for each session)
132:## Session N: YYYY-MM-DD
186:## Session 3: 2025-11-19 (Phase 2 Migration Session)
312:## Session 4: 2025-11-19 (Writer API & Managed ArrayList Migration)

```


**Tool Call: Read /Users/sean/code/opentui/packages/core/MIGRATION_LOG.md (313 - 432)**
Status: Completed

```
## Session 4: 2025-11-19 (Writer API & Managed ArrayList Migration)

### Work Completed

**Phase 2: Final API Migrations** ðŸ”§

Major API changes discovered and partially migrated - Zig 0.15.1 changed several fundamental APIs beyond just ArrayList/HashMap:

- **File**: build.zig.zon âœ…
  - Updated uucode dependency to latest commit (7e7f986) for better 0.15.1 compatibility
  - Old hash: `uucode-0.1.0-ZZjBPj96QADXyt5sqwBJUnhaDYs_qBeeKijZvlRa0eqM`
  - New hash: `122076a6479e2c192dc813197fcc95f64338e351933b15e6c7072a0f0b21a42af9a1`
  - Test result: Builds successfully with Zig 0.15.1

- **File**: renderer.zig ðŸŸ¡ (Partially Complete)
  - **BufferedWriter API Migration**:
    - Removed `std.io.BufferedWriter(4096, std.fs.File.Writer)` type
    - Added `stdout_buffer: [4096]u8` field to struct
    - Changed type to `std.fs.File.Writer` (new API uses buffer + writer pattern)
    - Updated initialization: `file.writer(&buffer)` instead of `BufferedWriter{...}`
    - Updated all `.writer()` calls â†’ `&stdoutWriter.interface`
    - Updated all `.flush()` calls â†’ `stdoutWriter.interface.flush()`
  
  - **API Changes Fixed**:
    - `std.io.getStdOut()` â†’ `std.fs.File.stdout()` (function call removed)
    - `std.time.sleep()` â†’ `std.Thread.sleep()` (moved to Thread namespace)
    - ArrayList `.deinit()` â†’ `.deinit(allocator)` (even for managed lists in 0.15.1!)
  
  - **ArrayList Default Change Discovered**:
    - In 0.15.1: `std.ArrayList` is now **Unmanaged by default** ðŸš¨
    - Old: `var list = std.ArrayList(T).init(allocator)`
    - New: `var list: std.ArrayList(T) = .{}`
    - Methods now require allocator: `.append(allocator, item)`, `.ensureTotalCapacity(allocator, N)`
    - This affects ALL remaining test and benchmark files!
  
  - Changes made:
    - 7 StatSample ArrayList initializations changed from `.init(allocator)` to `: .{}`
    - 7 `.ensureTotalCapacity()` calls updated to include allocator
    - 13 `.flush()` calls updated to use `.interface.flush()`
    - All `bufferedWriter.writer()` patterns replaced with `&stdoutWriter.interface`
  
  - Test result: Still has compilation errors (8-9 remaining)

- **File**: lib.zig ðŸŸ¡
  - Fixed `setTerminalTitle()` to use new Writer API
  - Changed `bufferedWriter.writer()` â†’ `&stdoutWriter.interface`
  - Removed `.any()` call (Writer is now concrete, not generic)
  - Test result: Function compiles

### Migration Insights

**Critical Discovery**: Zig 0.15.1 API changes are more extensive than initially documented:

1. **Writer/Reader Redesign** ("Writergate"):
   - Writers are no longer generic types - `std.Io.Writer` is a concrete struct
   - Buffering moved from wrapper types into the writer itself
   - Pattern: Create buffer â†’ `file.writer(&buffer)` â†’ use `&writer.interface`

2. **ArrayList Semantic Change**:
   - `std.ArrayList` now means `ArrayListUnmanaged` (huge breaking change!)
   - For managed lists, must use `std.ArrayListManaged` (not used in this codebase)
   - All methods require explicit allocator parameter
   - This explains why "managed" lists still needed allocator in deinit!

3. **Stdlib Reorganization**:
   - `std.io.getStdOut()` â†’ `std.fs.File.stdout()`
   - `std.time.sleep()` â†’ `std.Thread.sleep()`
   - These affect multiple files beyond just renderer.zig

### Issues Encountered

1. **Issue**: uucode dependency still had build.zig errors with first commit
   - Symptom: `std.Io.Writer.Allocating` API errors in dependency
   - Root cause: Commit 5f05f8f was from before full 0.15.1 migration
   - Resolution: Updated to latest commit (7e7f986) from 2025-11-19

2. **Issue**: BufferedWriter API completely changed
   - Symptom: No `.BufferedWriter` type exists in `std.io`
   - Root cause: Zig 0.15.1 redesigned I/O with built-in buffering
   - Resolution: Migrated to `std.fs.File.Writer` with explicit buffer
   - Impact: Required changes to struct fields, initialization, and all usage sites

3. **Issue**: ArrayList.init() doesn't exist
   - Symptom: `struct 'array_list.Aligned(f64,null)' has no member named 'init'`
   - Root cause: `std.ArrayList` defaulted to Unmanaged in 0.15.1
   - Resolution: Change initialization to `: std.ArrayList(T) = .{}`
   - Impact: ALL test and benchmark files will need this change

4. **Issue**: Custom OutputBufferWriter needs migration
   - Symptom: `std.io.Writer(void, error{BufferFull}, write)` - generic type no longer exists
   - Root cause: Writer is now a concrete type, not a generic
   - Status: **Not resolved** - complex custom writer, deferred to next session

5. **Issue**: ansi.zig uses deprecated Writer APIs
   - Symptom: `adaptToNewApi` and `writeByteNTimes` don't exist
   - Root cause: Writer interface completely redesigned
   - Status: **Not resolved** - requires ansi.zig migration (Phase 3)

### Test Results

**Compilation**: âš ï¸ IN PROGRESS (8-9 errors remaining)

Remaining compilation errors:
- `std.fmt.format` needs migration in ansi.zig (uses old writer.adaptToNewApi)
- `writer.writeByteNTimes` removed from API (ansi.zig:139)
- `OutputBufferWriter.writer()` returns generic `std.io.Writer` (doesn't exist)
- Various ArrayList.append() calls in addStatSample() need allocator parameter

**Files affected by remaining errors:**
- renderer.zig - OutputBufferWriter migration needed
- ansi.zig - fmt.format and writeByteNTimes APIs
- Functions using addStatSample() - need to pass allocator

**Progress**: Significant API understanding gained, ~60% of renderer.zig Writer migration complete

### Statistics

- **Files touched**: 3 (build.zig.zon, renderer.zig, lib.zig)
- **Writer API migrations**: ~30 call sites updated
- **ArrayList initialization changes**: 7


<file-read-info>Read lines 312-121. </file-read-info>
```

## Assistant

Now let me add Session 5 after Session 4:

**Tool Call: Check end of file**
Status: Completed

Terminal:
```

This is a **breaking semantic change** in Zig 0.15.1 that affects the entire codebase!

**Recommended Next Steps:**
1. Finish renderer.zig (OutputBufferWriter + addStatSample)
2. Quick pass through ansi.zig (fmt.format â†’ print)
3. Run `zig build test` to see full scope of test file errors
4. Decide: Migrate tests incrementally or batch process ArrayList changes

---

## Migration Statistics (Updated Each Session)

- **Sessions completed**: 4
- **Files fully migrated**: 8 (2 in Session 2, 6 in Session 3, 0 in Session 4)
- **Files partially migrated**: 2 (renderer.zig, lib.zig in Session 4)
- **Major API changes discovered**: 4 (Writer redesign, ArrayList default, stdlib reorganization, managed list deinit)
- **Tests passing**: Not yet run (compilation incomplete)
- **Benchmarks passing**: Not yet run


```


**Tool Call: Edit `/Users/sean/code/opentui/packages/core/MIGRATION_LOG.md`**
Status: Completed

Diff: /Users/sean/code/opentui/packages/core/MIGRATION_LOG.md
```
---

## Session 5: 2025-11-20 (Phase 2 & 3 Completion)

### Work Completed

**Phase 2 & 3: Final Core Migrations** âœ…

Successfully completed all core source file migrations! Build now passes with 0 errors.

- **File**: ansi.zig âœ…
  - **fmt.format migrations** (6 occurrences):
    - `std.fmt.format(writer, ...)` â†’ `writer.print(...)`
    - Updated functions: `moveToOutput`, `fgColorOutput`, `bgColorOutput`, `cursorColorOutputWriter`, `explicitWidthOutput`, `setTerminalTitleOutput`
  - **writeByteNTimes removal** (1 occurrence):
    - `writer.writeByteNTimes('\n', height - 1)` â†’ manual for loop
    - New pattern: `for (0..height - 1) |_| { writer.writeByte('\n') }`
  - Test result: Compiles successfully

- **File**: renderer.zig âœ…
  - **addStatSample migrations**:
    - Added `allocator: Allocator` parameter to function signature
    - Updated all 7 call sites to pass `self.allocator`
    - Fixed: `samples.append(value)` â†’ `samples.append(allocator, value)`
  
  - **OutputBufferWriter migration**:
    - Replaced custom writer struct with `std.io.FixedBufferStream`
    - New pattern: `getOutputBufferWriter()` returns FixedBufferStream
    - Added `updateOutputBufferLen()` to sync stream position back to buffer length
    - Changed: `var stream = getOutputBufferWriter(); const writer = stream.writer();`
    - Updated after last write: `updateOutputBufferLen(&stream);`
  
  - **file.writer() migrations** (3 debug dump functions):
    - All `file.writer()` calls now require buffer parameter: `file.writer(&buffer)`
    - Changed `const writer` â†’ `var writer` (interface needs mutable reference)
    - Updated all calls: `writer.interface.writeByte()`, `writer.interface.print()`, etc.
    - Added `writer.interface.flush()` before closing files
    - Functions updated: `dumpHitGrid`, `dumpSingleBuffer`, `dumpStdoutBuffer`
  
  - Test result: Compiles successfully

- **File**: lib.zig âœ…
  - No direct changes needed
  - Compilation fixed by ansi.zig migrations (uses ansi.zig functions)
  - Test result: Compiles successfully

### Migration Insights

**Pattern 15 Discovered**: FixedBufferStream for Custom Output Buffers

When you need a custom writer that writes to a pre-allocated buffer:

```zig
// Before (0.14.1) - Custom Writer struct
const OutputBufferWriter = struct {
    pub fn write(_: void, data: []const u8) !usize {
        // manual buffer management
    }
    pub fn writer() std.io.Writer(void, error{BufferFull}, write) {
        return .{ .context = {} };
    }
};

// After (0.15.1) - FixedBufferStream
fn getOutputBufferWriter() std.io.FixedBufferStream([]u8) {
    var stream = std.io.fixedBufferStream(buffer);  // Note: &buffer not buffer.*
    stream.pos = currentLen;  // Resume from current position
    return stream;
}

// Usage
var stream = getOutputBufferWriter();
const writer = stream.writer();
writer.writeAll(data) catch {};
updateBufferLen(&stream);  // Sync position back
```

**Key Learnings**:
1. `file.writer()` now requires buffer: `file.writer(&buffer)` not `file.writer()`
2. Writer must be `var` not `const` for mutable `&writer.interface` access
3. FixedBufferStream.pos tracks current write position
4. Need to sync position back to length variable after writes

### Issues Encountered

1. **Issue**: `fixedBufferStream(buffer.*)` failed
   - Symptom: "invalid type given to fixedBufferStream"
   - Root cause: Function expects slice reference, not dereferenced array
   - Resolution: Use `buffer` directly, not `buffer.*`

2. **Issue**: `writer.interface` is const pointer
   - Symptom: "expected type '*Io.Writer', found '*const Io.Writer'"
   - Root cause: `const writer` creates immutable binding
   - Resolution: Change to `var writer` for mutable interface access

### Test Results

**Compilation**: âœ… PASS

```bash
cd packages/core/src/zig
export PATH="$HOME/.zvm/bin:$PATH"
zig build
# Exit code: 0
# Output: (clean build)
```

All source files now compile successfully! ðŸŽ‰

**Phase 2 Complete**: All core data structures migrated
**Phase 3 Complete**: All I/O & formatting migrated (except rope.zig debug - low priority)

### Statistics

- **Files touched**: 2 (ansi.zig, renderer.zig)
- **Lines changed**: +60, -54 (renderer.zig), +6, -6 (ansi.zig)
- **fmt.format migrations**: 6 completed
- **Writer API migrations**: 13 additional call sites (debug dumps)
- **Custom writer migrations**: 1 (OutputBufferWriter â†’ FixedBufferStream)

### Commits

1. `zig: complete Phase 2 & 3 - migrate ansi.zig and renderer.zig to 0.15.1`
2. `zig: update migration status - Phase 2 & 3 complete (Session 5)`

### Next Steps

**Phase 4: Test Files** (14 files, 0 migrated)

Priority order:
1. Simple tests: grapheme_test.zig, utf8_test.zig, utils_test.zig
2. Core tests: rope_test.zig, buffer_test.zig
3. Complex tests: text-buffer_test.zig and related

Main migration pattern needed:
```zig
// Old
var list = std.ArrayList(T).init(allocator);
defer list.deinit();

// New
var list: std.ArrayList(T) = .{};
defer list.deinit(allocator);
```

All ArrayList methods need allocator parameter added.

---

## Migration Statistics (Updated Each Session)

- **Sessions completed**: 5
- **Files fully migrated**: 11 (2 in Session 2, 6 in Session 3, 0 in Session 4, 3 in Session 5)
- **Files partially migrated**: 0
- **Major API changes discovered**: 5 (Writer redesign, ArrayList default, stdlib reorganization, managed list deinit, FixedBufferStream pattern)
- **Build status**: âœ… PASSING (zig build succeeds)
- **Tests passing**: Not yet run (tests not migrated)
- **Benchmarks passing**: Not yet run
```


## Assistant

Perfect! Now let me commit this and mark the task as complete:

**Tool Call: Commit MIGRATION_LOG.md update**
Status: Completed

Terminal:
```
  â–¶ Check credentials by secretlint
[main 341b472] zig: add Session 5 to migration log
 1 file changed, 153 insertions(+), 5 deletions(-)



```


## Assistant

Perfect! Let me create a summary of what was accomplished:

## Session 5 Summary

**Phase 2 & Phase 3 Complete!** âœ…

Successfully migrated the remaining core files and achieved a clean build.

### Files Migrated
1. **ansi.zig** - All 6 `std.fmt.format()` calls converted to `writer.print()`, replaced `writeByteNTimes()` with manual loop
2. **renderer.zig** - Fixed `addStatSample()` allocator threading, migrated `OutputBufferWriter` to `FixedBufferStream`, updated all `file.writer()` calls
3. **lib.zig** - Fixed indirectly via ansi.zig changes

### Key Achievements
- âœ… **Build passes**: `zig build` completes with 0 errors
- âœ… **Phase 2 complete**: All 8 core data structure files migrated
- âœ… **Phase 3 complete**: All I/O & formatting files migrated (except low-priority rope.zig debug)
- ðŸ“Š **Progress**: 11/38 files (29%) fully migrated

### New Pattern Discovered
**Pattern 15**: FixedBufferStream for custom output buffers - replaces custom Writer structs with `std.io.FixedBufferStream`

### Migration Stats
- **Lines changed**: +60, -54 (renderer.zig), +6, -6 (ansi.zig)
- **Writer API migrations**: 13 additional call sites
- **fmt.format migrations**: 6 completed
- **Commits**: 3 total (source files, status update, log update)

### Next Steps
**Phase 4**: Begin test file migration (14 files remaining)
- Start with simple tests: grapheme_test.zig, utf8_test.zig, utils_test.zig
- Main pattern: ArrayList `.init(allocator)` â†’ `: ArrayList(T) = .{}`
- All ArrayList methods need allocator parameter

The build system is now clean and ready for test migrations!

